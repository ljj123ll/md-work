# 简历

软件工程专业 成都信息工程大学（一本）  2022.09-2026.06  校园经历：蓝桥杯 web 应用开发省赛一等奖  CET-4  

**专业技能：**

- 使用 HTML、CSS、JavaScript 进行页面开发，有良好的代码风格和 debug 能力 
- 使用 Vue3 框架及相关插件（如 VueRouter、Pinia 等）进行项目开发
- 使用 Element Plus、Ant Design 等组件库进行页面开发
- 使用 Formily 进行高性能的表单开发
- 使用 Git 进行协作开发，善用AI提高工作效率
- 使用 node+express 进行简单的后端开发
- 使用 Apifox 对后端接口进行测试，基于API定义自动生成 Mock 数据
- 搭建ESLint + Prettier + Husky工作流，强制代码风格统一，减少团队代码冲突

**可视化数据大屏解决方案            前端开发** 
项目背景：该项目旨在通过直观的数据可视化界面，帮助用户实时监控和分析项目关注度、开发者活跃
度、OpenRank 指数等核心指标。
技术栈：Vue3 + TypeScript + Echarts + Pinia + Vue Router + Ant Design Vue + Axios + Vite      
核心职责与成果：

- 跨端响应式架构设计
- 基于 PostCSS（px-to-rem）+ 媒体查询的响应式方案，实现 320px（手机）至 1920px（大 屏）多设 备适配，含 < 576px 移动端专属布局，设备兼容性达 95%+；通过监听窗口 resize 动态计算根 字体，解 决尺寸偏移问题，视觉一致性提升 40%。
- 高性能渲染与组件封装
- 使用不定高无限滚动虚拟列表，单屏仅加载 20 条数据，支持 10 万 + 条目流畅滚动，帧率从30fps 提升至 55fps+，卡顿率下降 60%；封装 Echarts 通用 hooks，复用代码 300 + 行，支持图表动态 切换与交互，开发效率提升 40%。
- 交互体验优化
- 实现虚拟列表与雷达图双向交互（点击添加/移除数据）解决高频更新重绘闪烁问题，响应速度≤100ms；通过预加载 6 张核心图片 + transition 动画，消除布局抖动。
- 工程化与性能调优
- 基于 Vite 配置分块打包，分离依赖与业务代码，首屏加载时间从 2.8s 降至 1.9s，提速 32%；集成 ESLint+Stylelint+Husky 工具链，代码评审通过率提升 50%，团队协作冲突率下降 35%。

**租客行（大疆及相机租赁网站）   全栈开发** 
项目背景：开发大疆及相机租赁平台 “租客行”，平台聚焦高端摄影器材租赁场景，支持用户浏览筛选设备、查
看详情、下单租赁、管理订单等全流程操作，同时开发后台管理系统实现产品、订单、用户数据的一站式管 控，服务摄影爱好者及专业创作者。
技术栈：Vue3 + TypeScript + Pinia + Vue Router + Element Plus + Axios + Vite + Express + MongoDB
项目职责与成果：

- 自定义v-lazy-img指令，基于IntersectionObserver 实现图片懒加载，缩短首屏加载时间；二次封装 Axios，统一处理 Token、Loading 与错误码，提升接口联调效率。
- 用 Pinia 拆分 3 大 Store 模块，结合插件 localStorage 实现数据持久化，解决刷新丢失问题；封装商 品全局组件，覆盖 3 大模块，减少冗余代码 1200 + 行。
- 配置keep-alive与导航守卫，处理路由缓存、登录拦截；重写scrollBehavior定制滚动行为，手动实现 导航吸顶。





# 公司1

WEB前端开发工程师
研发端  综合技术服务部

职位职责
岗位职责
1. 官网开发与维护:   参与公司全球官网的日常维护、功能迭代和新页面开发，确保官网的稳定性、性能和用户体验。
2. Shopify生态开发:   负责公司Shopify店铺的主题定制、功能模块开发、性能优化以及第三方应用的集成与维护。
3. 技术实现与还原:   将UI/UX设计稿精准地转化为高质量、语义化的HTML/CSS/JavaScript代码，实现流畅的页面交互和动态效果。
4. 跨端兼容与优化:   负责网页的性能优化，提升加载速度和运行效率；解决多浏览器（Chrome, Firefox, Safari等）、多终端（PC, Mobile）的兼容性问题。
5. 团队协作:   与业务部门，产品经理、UI/UX设计师、后端工程师等团队成员紧密协作，沟通需求、反馈问题，共同确保项目按时高质量交付。
6. 技术探索与创新:   持续学习和研究前端前沿技术（如性能优化、新的CSS特性、框架新版本等），并将其应用于实际项目中，提升团队整体技术水平。

任职要求
1. 学历背景:   本科及以上学历，计算机科学、软件工程等相关专业优先。
2. 前端基础:   扎实的HTML5、CSS3、JavaScript (ES6+) 基础，理解W3C标准、语义化、盒模型、响应式布局等核心概念。
3. 框架经验:   了解至少一种主流前端框架（如Vue.js, React），了解基本使用、组件化开发思想和生命周期。有实际项目经验者优先 





# 前端面试问题（基于你的简历）

## 一、校园经历与基础能力考察
1. 你在蓝桥杯 Web 应用开发省赛中获得了一等奖，能否用 **STAR 法则** 分享一个比赛中你印象最深的技术难点？比如“如何解决某个功能的性能瓶颈/兼容性问题”，需要说明当时的场景、任务、你的行动（技术方案）及最终结果（比如耗时、效果）。  
2. 比赛中你使用的技术栈和你简历中提到的 Vue3、TypeScript 等是否一致？如果不一致（比如用了原生 JS/ jQuery），你是如何快速适配并迁移到 Vue3 生态的？过程中遇到的核心差异点是什么？


## 二、专业技能深挖
1. 你提到“使用 Formily 进行高性能的表单开发”，Formily 相比 Element Plus/Ant Design Vue 自带的表单组件，在“高性能”上的核心优势是什么？请举例说明你在项目中如何用 Formily 解决“复杂表单（比如 20+ 字段、联动逻辑多）”的性能问题（比如减少重渲染、优化联动响应速度）。  
2. 你搭建过“ESLint + Prettier + Husky 工作流”，实际团队协作中，是否遇到过成员对规则不适应（比如代码风格冲突）、或 Husky 钩子执行失败（比如 commit 时 lint 报错但无法定位）的情况？你是如何解决这些问题的？是否有根据团队需求自定义过 ESLint 规则（比如禁止使用 `var`、强制组件名 PascalCase）？  
3. 你用 Node + Express 做过简单后端开发，在“租客行”项目中，后端接口是否涉及“用户登录鉴权”或“订单数据CRUD”？比如：你是如何实现 Token 鉴权的（Token 存储位置、过期刷新逻辑）？MongoDB 中你是如何设计“订单表”的结构（比如关联用户 ID、设备 ID、租赁时间等字段）？是否遇到过 MongoDB 查询性能问题（比如大数据量筛选）？如何优化的？  
4. 你提到“善用 AI 提高工作效率”，能否举 1-2 个具体场景？比如“用 AI 生成 Echarts 配置模板”“排查某个复杂 Bug 时用 AI 辅助定位”，需要说明 AI 帮你解决了什么问题、你如何验证 AI 给出方案的正确性（避免踩坑）。


## 三、项目一：可视化数据大屏（前端开发）
1. 响应式方案：你用“PostCSS px-to-rem + 媒体查询”实现了 320px-1920px 适配，还处理了 <576px 移动端专属布局。有两个细节想确认：  
   - 监听窗口 `resize` 事件动态计算根字体大小时，是否做了 **防抖优化**？如果没做，会有什么问题？如果做了，防抖的延迟时间是多少？如何确定这个值的合理性？  
   - 移动端专属布局和桌面端布局的切换阈值（比如 576px）是如何确定的？是否参考了行业标准（比如 Bootstrap 栅格）？切换时是否有布局抖动？你是如何用 `transition` 优化的？  
2. 高性能渲染：你实现了“不定高无限滚动虚拟列表”，支持 10 万+ 条目流畅滚动，帧率从 30fps 提升到 55fps+。请详细说明：  
   - 不定高虚拟列表的核心实现逻辑：比如“如何预估/计算每个列表项的高度”“如何处理滚动时的 DOM 复用（比如只渲染可视区 20 条）”“滚动到未预计算高度的区域时，如何避免布局跳动”？  
   - 帧率提升从 30 到 55 是通过什么工具测量的？（比如 Chrome DevTools 的 Performance 面板？）测量时的测试条件（比如数据量、设备）是什么？除了虚拟列表，还有没有其他优化手段（比如数据分片加载、避免重排重绘）？  
3. Echarts 通用 Hooks 封装：你提到“复用代码 300+ 行，支持图表动态切换与交互”。这个 Hooks 具体封装了哪些核心逻辑？比如：  
   - 是否包含“图表初始化、销毁（避免内存泄漏）、数据更新、resize 自适应”？  
   - 如何支持“动态切换图表类型”（比如从折线图切换到柱状图）？是否需要处理不同图表类型的配置差异（比如折线图的 `lineStyle` 和柱状图的 `barWidth`）？  
   - 图表交互（比如点击图例筛选数据）是在 Hooks 内部处理，还是通过回调暴露给组件？为什么这么设计？  
4. 工程化优化：你通过 Vite 分块打包将首屏加载时间从 2.8s 降至 1.9s。请说明：  
   - Vite 分块打包的具体配置：比如是否用了 `build.rollupOptions` 中的 `splitChunks` 拆分第三方依赖（如 Echarts、Ant Design Vue）和业务代码？拆分后依赖包的体积变化是多少？  
   - 首屏加载时间是如何测量的？（比如用 Chrome DevTools 的 Network 面板看 `Load` 时间，还是用 LCP 指标？）除了分块打包，你还尝试过哪些性能优化手段（比如图片压缩、CDN 加速、预加载/Prefetch）？效果如何？


## 四、项目二：租客行（全栈开发）
1. 自定义指令：你实现了 `v-lazy-img` 指令，基于 IntersectionObserver 实现图片懒加载。请说明：  
   - 指令的核心逻辑：比如“如何判断图片进入视口”“进入视口后如何加载图片（替换 `src` 还是 `data-src`）”“如何处理图片加载失败的降级方案（比如显示默认占位图）”？  
   - IntersectionObserver 的配置参数（比如 `rootMargin`、`threshold`）是如何设置的？为什么这么配置？比如 `rootMargin: '100px 0px'` 的作用是什么？  
2. Axios 二次封装：你提到“统一处理 Token、Loading 与错误码”。具体实现细节：  
   - Token 是存在哪里的（localStorage/sessionStorage/cookie）？为什么选择这个存储方式？是否考虑过 XSS 攻击风险（比如 localStorage 被篡改）？  
   - 错误码统一处理：比如遇到 401（Token 过期）、403（无权限）、500（服务器错误）时，分别做了什么处理？401 时是否实现了“无感刷新 Token”（比如用刷新令牌重新获取 Token，再重试原请求）？  
   - Loading 统一处理：是每个请求都加 Loading，还是可配置（比如某些请求不需要 Loading）？如何避免“多个请求同时触发时，Loading 频繁显示/隐藏”的问题？  
3. Pinia 与路由：  
   - 你将 Pinia 拆分为 3 大 Store 模块，能否具体说明是哪 3 个模块（比如 `userStore`、`goodsStore`、`orderStore`）？每个模块的核心状态（State）和动作（Action）是什么？比如 `orderStore` 中是否包含“创建订单”“查询订单列表”等 Action？  
   - 用 Pinia 插件实现 localStorage 持久化时，是否存储了敏感数据（比如用户 Token、手机号）？如果有，如何避免安全风险（比如加密存储）？如果没有，敏感数据是如何处理的？  
   - 你“重写 scrollBehavior 定制滚动行为，手动实现导航吸顶”：scrollBehavior 具体定制了什么场景？比如“返回上一页时恢复之前的滚动位置”？导航吸顶是通过监听 `scroll` 事件实现的吗？是否做了防抖优化？如何判断“导航需要吸顶的阈值”（比如滚动距离 > 导航高度）？  
4. 全栈协作：这个项目你是全栈开发（前端+后端），请分享一个“前后端联调”中遇到的典型问题。比如“后端接口返回格式与前端预期不一致”“跨域问题”，你是如何定位（比如用 Apifox 测接口、看 Network 响应）并解决的？


## 五、通用能力与技术规划
1. 你在两个项目中都涉及“性能优化”（比如虚拟列表、分块打包、懒加载），除了简历中提到的手段，你还了解哪些前端性能优化方向？比如“资源层面（CDN、缓存策略）”“代码层面（Tree Shaking、减少重排重绘）”“渲染层面（SSR/SSG）”，能否举 1-2 个你没在项目中实践过，但深入研究过的方案？  
2. 假设你加入团队后，需要接手一个“老项目”（比如 Vue2 + Vuex 开发，代码规范混乱，性能瓶颈多），你会从哪三步开始入手改造？优先级如何排序（比如先理规范、再优化性能、最后迁移技术栈）？  
3. 你未来 6-12 个月的技术学习规划是什么？比如“深入学习 Vue3 源码”“学习 React 生态”“研究前端工程化（如 Monorepo）”，为什么选择这个方向？计划如何落地（比如看哪些文档、做什么 Demo 项目）？





我会结合你的简历经历（校园竞赛、项目实践、技能栈），针对每个问题给出逻辑清晰、技术细节饱满的回答，部分场景融入STAR法则，同时拓展相关技术原理，体现你的实践深度和知识广度。


### 一、校园经历与基础能力考察
#### 1. 蓝桥杯Web省赛一等奖的技术难点（STAR法则）
**回答**：  
- **S（情境）**：比赛题目是开发“校园社团管理系统”，核心模块是“社团活动报名统计页”——需要实时展示各活动的报名人数、筛选条件（活动类型/时间）联动统计图表，且页面要兼容Chrome、Firefox及低版本Edge（当时遇到Edge下图表渲染错位问题），比赛限时4小时，时间紧张。  
- **T（任务）**：两个核心目标：① 实现“筛选条件+图表+报名列表”的实时联动，避免筛选时页面卡顿；② 修复低版本Edge浏览器的图表渲染兼容问题，确保功能完整性。  
- **A（行动）**：  
  1. 解决联动性能问题：最初用原生JS写筛选逻辑，每次筛选都重新请求数据+全量渲染列表，导致卡顿。后来优化为“本地数据缓存+增量渲染”——首次加载时把所有活动数据存在数组里，筛选时只对本地数据做过滤，列表用“文档片段（DocumentFragment）”批量插入DOM，减少重排次数；  
  2. 解决Edge兼容问题：图表用ECharts 4.x（当时比赛提供的版本），Edge下图表容器宽高计算错误，排查后发现是Edge对`getComputedStyle`的`width`返回值带“px”后缀但未自动解析，手动写了工具函数`parsePxValue(styleValue)`提取数值，再传给ECharts的`setOption`；  
  3. 最后用`addEventListener('resize', debounce(handleChartResize, 100))`处理窗口缩放，避免图表变形。  
- **R（结果）**：最终实现筛选响应时间从300ms降至50ms内，Edge浏览器图表渲染完全正常，该模块得分占比30%，为拿一等奖奠定基础；同时积累了“原生JS性能优化”和“浏览器兼容处理”的经验，后续学Vue3时能快速理解“虚拟DOM减少重排”的设计思路。

#### 2. 比赛技术栈与Vue3生态的迁移适配
**回答**：比赛用的是“原生HTML/CSS/JS + jQuery + ECharts”，和Vue3生态差异主要在3个点，我是这么适配的：  
1. **DOM操作思维转响应式思维**：原生开发时习惯用`$('#id').val()`直接操作DOM，迁移Vue3时先学`ref/reactive`的响应式原理，用“数据驱动视图”替代手动DOM操作——比如之前用jQuery写表单联动，现在用`watch`监听表单值变化，自动更新关联字段，减少了代码耦合；  
2. **模块化方案差异**：比赛时用`script`标签引入文件，Vue3用ES Module（`import/export`），我先通过Vite初始化项目，理解`main.js`入口、组件导入导出逻辑，再封装通用工具（如比赛时写的日期格式化函数，改成Vue3的`hooks`复用）；  
3. **状态管理**：比赛时用全局变量存状态（如当前选中的活动ID），容易冲突，学Vue3时重点研究Pinia——把全局状态拆分成`userStore`、`activityStore`，通过`defineStore`定义，用`actions`处理异步逻辑（比如之前用jQuery.ajax，现在用Axios+Pinia actions），状态管理更清晰。  
迁移过程中还做了“原生项目转Vue3 Demo”：把比赛的报名统计页用Vue3重写，对比两种方案的代码量（Vue3版减少40%），加深了对框架优势的理解。


### 二、专业技能深挖
#### 1. Formily的高性能优势及复杂表单实践
**回答**：Element Plus/AntD Vue的原生表单在复杂场景（20+字段、多层联动）下有两个痛点：① 字段联动时容易触发整个表单重渲染，导致输入卡顿；② 动态增减字段（如“添加联系人”）时，需要手动维护表单结构，代码冗余。Formily的核心优势就是“精准控制重渲染”和“动态表单能力”，我在数据大屏项目的“权限配置表单”中用过：  
- 场景：表单含“角色选择（下拉）”“权限勾选（20+复选框）”“数据范围（动态增减输入框）”，且“角色选择”会联动“权限复选框的默认勾选状态”，“权限勾选”会控制“数据范围”是否显示。  
- 具体优化：  
  1. 精准重渲染：Formily用“字段级响应式”，每个字段是独立的响应式单元，只有联动相关的字段会重渲染——比如选角色时，只有权限复选框更新，其他字段不重渲染；用Element Plus时，选角色会触发整个表单重渲染，输入延迟从200ms降至50ms；  
  2. 动态表单：用Formily的`ArrayTable`组件实现“数据范围动态增减”，只需配置`name: 'dataRange'`和`onAdd/onRemove`，无需手动维护数组和表单绑定，比Element Plus的`el-form-item`循环减少150+行代码；  
  3. 性能监控：用Formily DevTools查看重渲染次数，发现“权限复选框”初始有冗余重渲染，通过`useField` hooks手动控制依赖，进一步优化后，表单整体渲染性能提升60%。  
  Formily的底层是通过“路径化状态管理”实现的——每个字段对应唯一的“路径（如`role.permissions`）”，只更新路径匹配的字段，这是它比传统表单组件高性能的核心原因。

#### 2. ESLint+Prettier+Husky的问题解决与自定义规则
**回答**：在租客行项目团队（5人协作）中遇到过两个典型问题，解决方案如下：  
- 问题1：成员对“分号是否保留”“单引号/双引号”有分歧，提交代码时Prettier格式化不一致。  
  解决：① 组织团队投票确定规则（最终选“不保留分号”“单引号”）；② 在`prettier.config.js`中明确配置`{ semi: false, singleQuote: true }`；③ 写《团队代码规范文档》，附配置示例，新人入职时同步；  
- 问题2：Husky的`pre-commit`钩子执行时，ESLint报错但无法定位文件（比如“未使用变量”），导致成员无法提交代码。  
  解决：① 排查发现是`lint-staged`配置问题——只 lint 暂存区文件，但报错信息没带文件路径；② 修改`package.json`的`lint-staged`配置，添加`"*.{js,vue}": ["eslint --fix --ext .js,.vue --format=codeframe"]`，用`codeframe`格式显示报错文件路径和行号，成员能快速定位修改；  
- 自定义规则：根据项目需求加了3条核心规则：  
  1. `no-var`：禁止用`var`，避免变量提升问题；  
  2. `vue/component-name-in-template-casing`：强制组件名用PascalCase（如`<UserForm>`），统一模板风格；  
  3. `no-console`：开发环境允许`console.log`，生产环境禁止（用`eslint-plugin-unicorn`的`no-console`，配合`process.env.NODE_ENV`判断）。  
  优化后，团队代码评审时“风格类问题”减少80%，冲突率从之前的35%降至5%。

#### 3. Node+Express的鉴权与MongoDB优化
**回答**：在租客行项目中，后端确实涉及“用户登录鉴权”和“订单CRUD”，具体实现如下：  
- Token鉴权：  
  1. 存储位置：用localStorage存Token（考虑到项目是PC端租赁网站，无移动端原生需求，且需要跨页面共享Token）；同时做了安全兜底——前端请求时通过Axios拦截器给Header加`Authorization: Bearer ${token}`，后端Express用`jsonwebtoken`验证，过期时间设为2小时；  
  2. 过期刷新：实现“无感刷新”——在Axios响应拦截器中捕获401错误，判断是Token过期后，用“刷新令牌（存在httpOnly Cookie中，避免XSS）”调用`/api/refresh-token`接口，获取新Token后更新localStorage，再重试原请求；  
- MongoDB订单表设计：  
  结构核心字段：`_id`（默认主键）、`userId`（关联用户表，ObjectId类型）、`deviceIds`（租赁设备ID数组，[ObjectId]）、`rentTime`（租赁时长，{ start: Date, end: Date }）、`totalPrice`（总价，Number）、`status`（状态：待支付/已支付/已归还，String）；  
  索引优化：最初查询“用户的所有订单”时用`db.orders.find({ userId: ObjectId('xxx') })`，1万条数据耗时300ms，给`userId`加单字段索引（`db.orders.createIndex({ userId: 1 })`）后，耗时降至50ms；后续又加了“状态+时间”复合索引（`{ status: 1, 'rentTime.start': -1 }`），优化“筛选未归还订单并按时间排序”的查询；  
- 其他处理：用`mongoose`做ODM（对象文档映射），定义订单Schema时加字段验证（如`totalPrice`必须大于0），避免脏数据存入数据库。

#### 4. AI工具提升效率的具体场景
**回答**：我常用ChatGPT和Cursor（AI编辑器），两个典型场景：  
1. 生成Echarts配置模板：数据大屏项目需要做“OpenRank指数趋势图”，要求支持“hover显示详细数据”“多曲线对比”“缩放交互”。最初手动写配置容易漏细节（比如`tooltip`的`triggerOn`设置），用ChatGPT输入prompt：“基于Echarts 5.x生成OpenRank指数趋势图，支持hover显示日期、指数值，多曲线对比，添加缩放工具栏，适配响应式容器”，AI生成基础配置后，我再调整样式（如颜色、线宽）和数据映射逻辑，节省40%配置时间；同时验证正确性——对照Echarts官方文档检查`dataZoom`组件的`type: 'inside'`是否正确，本地测试缩放功能是否生效；  
2. 定位复杂Bug：租客行项目中，虚拟列表滚动时偶尔出现“数据重复渲染”，排查1小时没找到原因。用Cursor的“Debug模式”粘贴代码（虚拟列表的`handleScroll`函数），AI提示“计算可视区起始索引时，没有考虑列表项的实际高度修正，导致滚动时索引计算偏差”——原来我之前用的是固定预估高度，没在列表项渲染后更新实际高度。根据提示修改代码（在`onRendered`钩子中更新每个项的实际高度），Bug解决；后续还手动复现了“高度偏差场景”（比如某列表项内容换行导致高度增加），确认修复彻底。  
核心原则：AI是“辅助工具”，不是“替代方案”——生成的代码会对照官方文档验证，复杂逻辑会本地测试，避免AI给出的“看似正确但有隐藏问题”的方案。


### 三、项目一：可视化数据大屏（前端开发）
#### 1. 响应式方案的防抖与布局优化
**回答**：  
- resize防抖处理：必须做防抖！因为窗口缩放时`resize`事件会高频触发（每秒几十次），不防抖会导致根字体计算频繁，页面卡顿。我设置的防抖延迟是100ms——理由是：① 低于50ms的话，防抖效果不明显，仍有高频触发；② 高于150ms会让页面响应有延迟感，100ms是“性能”和“响应速度”的平衡点。代码实现用了lodash的`debounce`，同时在组件卸载时清除事件监听（避免内存泄漏）：  
  ```js
  onMounted(() => {
    const handleResize = debounce(calculateRootFontSize, 100);
    window.addEventListener('resize', handleResize);
    onUnmounted(() => window.removeEventListener('resize', handleResize));
  });
  ```
- 移动端阈值与布局切换：阈值576px参考了Bootstrap栅格系统的“sm”断点（行业通用标准，用户认知一致），同时结合项目实际——调研发现租赁网站的移动端用户80%用5英寸以上手机（宽度≥360px），576px能覆盖“平板竖屏”和“大尺寸手机”的过渡场景。切换时避免抖动的方案：① 用`transition: all 0.3s ease`包裹核心布局容器（如数据卡片），让布局变化有平滑动画；② 移动端专属布局用`@media (max-width: 576px) { ... }`写独立样式，且避免用“突然隐藏/显示”（如`display: none`），改用`opacity`和`transform`过渡，减少重排；  
- 效果验证：用Chrome DevTools的“设备工具栏”模拟不同尺寸（320px、576px、1920px），视觉一致性通过“设计稿对比”——移动端布局与设计稿偏差≤2px，设备兼容性通过“BrowserStack”测试，覆盖10种主流设备，兼容率达96%（超预期的95%）。

#### 2. 不定高无限滚动虚拟列表的实现与性能测量
**回答**：  
- 核心实现逻辑：不定高的难点是“无法提前知道每个列表项的高度”，我的方案是“预估高度+实际测量修正”：  
  1. 初始化：给每个列表项设置预估高度（如60px，根据设计稿平均高度设定），计算“可视区能容纳的项数”（`Math.ceil(容器高度 / 预估高度)`），初始渲染20条（略多于可视区，避免滚动时空白）；  
  2. 滚动计算：监听`scroll`事件，获取滚动距离`scrollTop`，计算“可视区起始索引”（`Math.floor(scrollTop / 预估高度)`）和“结束索引”（起始索引+20）；然后通过“定位偏移”（给列表项容器加`transform: translateY(${起始索引 * 预估高度}px)`），让可视区内容始终在窗口内；  
  3. 高度修正：列表项渲染后，用`offsetHeight`获取实际高度，存入“高度缓存数组”（`heightCache[index] = 实际高度`）；下次滚动时，用缓存的实际高度重新计算起始索引，避免偏差——比如某列表项实际高度80px，之前预估60px，修正后索引计算更准确，不会出现“滚动时内容跳变”；  
  4. 数据处理：10万+条目分“批次加载”——初始加载前200条，滚动到“剩余50条”时，再请求下一批（用`IntersectionObserver`监听“加载更多”占位符），避免一次性加载大量数据导致内存占用过高；  
- 性能测量：用Chrome DevTools的“Performance”面板录制30秒滚动过程，测量帧率——测试条件：10万条模拟数据（每条含“设备名称”“租赁次数”等5个字段），PC端（i5-10400F，16GB内存），Chrome 112版本。优化前（无虚拟列表）帧率波动在25-30fps，有明显卡顿；优化后帧率稳定在55-60fps，卡顿率从优化前的40%降至8%（卡顿率=帧率<50fps的时间/总时间）；  
- 其他优化：给列表项加`will-change: transform`，让浏览器提前优化渲染；避免在列表项中用复杂组件（如Echarts小图表），改用静态图标+文字，减少渲染压力。

#### 3. Echarts通用Hooks的封装细节
**回答**：这个Hooks叫`useEcharts`，封装在`src/hooks/useEcharts.js`，核心逻辑覆盖“生命周期管理+动态交互+复用适配”，代码约300行，具体如下：  
- 1. 基础生命周期（初始化、销毁、resize）：  
  - 初始化：接收`domRef`（图表容器ref）、`initOption`（初始配置），在`onMounted`中调用`echarts.init(domRef.value)`，并`setOption(initOption)`；  
  - 销毁：在`onUnmounted`中调用`chart.dispose()`，避免Echarts实例内存泄漏（之前没销毁时，切换页面后内存占用增加200MB+，销毁后恢复正常）；  
  - resize适配：监听窗口`resize`（防抖100ms），调用`chart.resize()`，同时支持手动触发（暴露`handleResize`方法）；  
- 2. 动态切换图表类型：通过“配置合并”实现——比如从“折线图”切换到“柱状图”，只需传入新的`series.type`，Hooks内部用`Object.assign`合并基础配置和新配置，避免重复写完整`option`：  
  ```js
  // 暴露updateOption方法
  const updateOption = (newOption) => {
    const mergedOption = Object.assign({}, chart.getOption(), newOption);
    chart.setOption(mergedOption, true); // 第二个参数true表示不合并series，适合类型切换
  };
  ```
  比如切换时调用`updateOption({ series: [{ type: 'bar' }] })`，即可完成类型切换，同时保留xAxis、yAxis等基础配置；  
- 3. 交互逻辑处理：采用“回调暴露”设计——Hooks内部监听Echarts的`click`、`legendselectchanged`等事件，将事件参数通过回调传给组件，不在Hooks内部硬编码业务逻辑，保证复用性：  
  ```js
  // 接收组件传入的onChartClick回调
  const { onChartClick } = props;
  chart.on('click', (params) => {
    if (onChartClick) onChartClick(params); // 把点击参数传给组件处理
  });
  ```
  比如数据大屏的“雷达图”点击事件，组件中调用`useEcharts({ onChartClick: (params) => handleRadarClick(params) })`，在`handleRadarClick`中处理“添加/移除数据”的业务逻辑，Hooks只负责事件转发，解耦度高；  
- 复用效果：这个Hooks在项目中被6个图表组件复用（趋势图、雷达图、饼图等），每个组件只需传入容器ref和个性化配置，平均减少150行/组件的重复代码，开发效率提升40%（原本每个图表写初始化、resize等逻辑需2小时，现在1小时内完成）。

#### 4. Vite分块打包与首屏优化
**回答**：  
- Vite分块打包配置：核心是用`build.rollupOptions.splitChunks`拆分第三方依赖和业务代码，避免单文件过大。`vite.config.js`配置如下：  
  ```js
  export default defineConfig({
    build: {
      rollupOptions: {
        output: {
          // 拆分第三方依赖（如Echarts、AntD Vue）
          manualChunks: {
            echarts: ['echarts'],
            antd: ['ant-design-vue'],
            vue: ['vue', 'vue-router', 'pinia']
          },
          // 业务代码按目录拆分
          chunks: 'commonjs'
        }
      }
    }
  });
  ```
  拆分后，第三方依赖包体积变化：原本单个`vendor.js`约1.2MB，拆分后`echarts.js` 500KB、`antd.js` 400KB、`vue.js` 300KB，支持并行加载；  
- 首屏加载时间测量：用Chrome DevTools的“Performance”面板测LCP（最大内容绘制）指标——优化前LCP是2.8s（主要瓶颈是`vendor.js`加载慢），优化后LCP 1.9s，同时用“Network”面板看首屏资源加载大小：从2.1MB降至1.5MB，提速32%；  
- 其他优化手段：  
  1. 图片压缩：核心图片（如logo、背景图）用TinyPNG压缩，平均体积减少60%，同时用`webp`格式（兼容时优先加载，不兼容时降级为png）；  
  2. 预加载（Preload）：对首屏关键资源（如`main.js`、首页背景图）加`<link rel="preload" href="xxx" as="script/image">`，提前加载，减少首屏等待时间；  
  3. CDN加速：将Echarts、Vue等第三方依赖换成阿里云CDN加载（配置`vite.config.js`的`resolve.alias`指向CDN地址），减少服务器带宽压力，同时CDN节点更近，加载更快；  
- 效果验证：用“Lighthouse”测试首屏性能得分，从优化前的68分（良）提升到85分（优），满足项目“首屏加载≤2s”的需求。


### 四、项目二：租客行（全栈开发）
#### 1. 自定义v-lazy-img指令的实现
**回答**：这个指令主要解决“商品列表页（20+张设备图片）首屏加载慢”的问题，基于IntersectionObserver API实现，核心逻辑分4步：  
- 1. 指令钩子设计：用Vue3的`directive`定义，核心钩子是`mounted`（初始化监听）和`unmounted`（清除监听，避免内存泄漏）：  
  ```js
  app.directive('lazy-img', {
    mounted(el, binding) {
      // el是图片元素，binding.value是目标图片地址
      el.dataset.src = binding.value; // 先把真实地址存在data-src，src设为占位图
      el.src = require('@/assets/placehold.png'); // 占位图（1KB小图）
      initObserver(el); // 初始化IntersectionObserver
    },
    unmounted(el) {
      if (el._observer) el._observer.unobserve(el); // 清除监听
    }
  });
  ```
- 2. IntersectionObserver配置：关键参数`rootMargin`设为`100px 0px`，`threshold`设为`0.1`：  
  - `rootMargin: '100px 0px'`：图片进入视口前100px就开始加载，避免用户滚动到图片时还在加载，提升体验；  
  - `threshold: 0.1`：图片有10%进入视口时触发加载，避免“图片边缘刚进入就加载”的冗余请求；  
  初始化代码：  
  ```js
  const initObserver = (el) => {
    el._observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) { // 图片进入视口
          const img = new Image(); // 预加载图片
          img.src = el.dataset.src;
          img.onload = () => {
            el.src = el.dataset.src; // 预加载完成后替换src
            el.classList.add('fade-in'); // 加淡入动画（transition: opacity 0.3s）
          };
          img.onerror = () => {
            el.src = require('@/assets/error.png'); // 加载失败显示错误图
          };
          el._observer.unobserve(el); // 加载完成后停止监听
        }
      });
    }, { rootMargin: '100px 0px', threshold: 0.1 });
    el._observer.observe(el); // 开始监听图片元素
  };
  ```
- 3. 降级处理：考虑到IE浏览器不支持IntersectionObserver（项目PC端用户IE占比<5%，但仍做兼容），在指令初始化时判断：  
  ```js
  if (!window.IntersectionObserver) {
    // 降级为滚动监听（防抖100ms）
    el.src = el.dataset.src; // 直接加载图片，避免IE用户看不到图片
  }
  ```
- 效果：商品列表页首屏加载时间从1.8s降至1.1s，图片加载请求数从“一次性20+个”变为“首屏只加载5-6个”，节省带宽40%。

#### 2. Axios二次封装的细节
**回答**：封装在`src/utils/request.js`，核心是“请求拦截器+响应拦截器”，覆盖Token、Loading、错误码处理，具体如下：  
- 1. Token处理：  
  - 存储：Token存在localStorage（`localStorage.getItem('token')`），选择localStorage是因为项目需要跨页面共享Token（如从登录页到商品页）；同时考虑XSS风险——在Axios请求拦截器中加了“Token合法性校验”（简单判断是否为JWT格式，含`.`分隔的三部分），避免篡改后的无效Token发送到后端；  
  - 请求拦截：每次请求前给Header加`Authorization`：  
    ```js
    request.interceptors.request.use(config => {
      const token = localStorage.getItem('token');
      if (token && /^[\w-]+\.[\w-]+\.[\w-]+$/.test(token)) { // 简单JWT格式校验
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    ```
- 2. 错误码统一处理：  
  响应拦截器中捕获不同错误码，做对应处理：  
  ```js
  request.interceptors.response.use(
    response => response.data, // 正常响应直接返回data
    error => {
      const status = error.response?.status;
      switch (status) {
        case 401: // Token过期
          handleTokenExpire(); // 无感刷新Token
          break;
        case 403: // 无权限
          ElMessage.error('您没有操作权限');
          router.push('/no-permission'); // 跳无权限页
          break;
        case 500: // 服务器错误
          ElMessage.error('服务器异常，请稍后重试');
          // 上报错误日志（用阿里云日志服务）
          reportError(error);
          break;
        default:
          ElMessage.error(error.response?.data?.msg || '请求失败');
      }
      return Promise.reject(error);
    }
  );
  ```
  其中`handleTokenExpire`实现无感刷新：  
  ```js
  let isRefreshing = false; // 避免同时触发多个刷新请求
  let retryQueue = []; // 重试队列
  const handleTokenExpire = () => {
    if (!isRefreshing) {
      isRefreshing = true;
      // 用刷新令牌（存在httpOnly Cookie）请求新Token
      request.post('/api/refresh-token').then(res => {
        const newToken = res.data.token;
        localStorage.setItem('token', newToken);
        // 重试队列中的请求
        retryQueue.forEach(cb => cb(newToken));
        retryQueue = [];
      }).finally(() => {
        isRefreshing = false;
      });
    }
    // 返回Promise，让原请求等待刷新完成后重试
    return new Promise(resolve => {
      retryQueue.push((newToken) => {
        error.config.headers.Authorization = `Bearer ${newToken}`;
        resolve(request(error.config)); // 重试原请求
      });
    });
  };
  ```
- 3. Loading统一处理：  
  支持“全局Loading”和“单个请求Loading”可配置，通过请求`config`中的`loading`参数控制：  
  ```js
  let loadingCount = 0; // 计数避免多个请求频繁显示/隐藏Loading
  const showLoading = () => {
    if (loadingCount === 0) ElLoading.service({ fullscreen: true });
    loadingCount++;
  };
  const hideLoading = () => {
    loadingCount--;
    if (loadingCount === 0) ElLoading.service().close();
  };
  
  // 请求拦截器中显示Loading
  request.interceptors.request.use(config => {
    if (config.loading !== false) showLoading(); // 默认显示，配置loading: false不显示
    // ...其他逻辑
    return config;
  });
  
  // 响应/错误拦截器中隐藏Loading
  request.interceptors.response.use(
    response => {
      if (response.config.loading !== false) hideLoading();
      return response.data;
    },
    error => {
      if (error.config?.loading !== false) hideLoading();
      // ...其他错误处理
      return Promise.reject(error);
    }
  );
  ```
  比如“获取商品列表”请求不需要Loading，调用时传`request.get('/api/goods', { loading: false })`；  
- 效果：接口联调效率提升50%（之前每个请求手动加Token、写Loading，现在只需调用封装后的request），且401错误用户无感知，体验更好。

#### 3. Pinia模块设计与路由优化
**回答**：  
- Pinia 3大Store模块设计：结合项目业务（用户、商品、订单）拆分，每个模块职责单一：  
  1. `userStore`（用户模块）：  
     - State：`userInfo`（用户信息，含id、name、role）、`isLogin`（是否登录，布尔值）；  
     - Actions：`login(data)`（登录请求，调用`/api/login`，存储Token和userInfo）、`logout()`（退出登录，清除localStorage和State）、`getUserInfo()`（获取当前用户信息，用于页面刷新后恢复状态）；  
  2. `goodsStore`（商品模块）：  
     - State：`goodsList`（商品列表，数组）、`filterParams`（筛选参数，含设备类型、价格区间）、`total`（商品总数，用于分页）；  
     - Actions：`getGoodsList()`（获取商品列表，带筛选参数）、`updateFilterParams(params)`（更新筛选参数）；  
  3. `orderStore`（订单模块）：  
     - State：`currentOrder`（当前选中订单，对象）、`orderList`（用户订单列表，数组）；  
     - Actions：`createOrder(data)`（创建订单）、`getOrderList()`（获取用户订单）、`updateOrderStatus(id, status)`（更新订单状态）；  
- Pinia持久化与敏感数据处理：  
  用`pinia-plugin-persistedstate`插件实现持久化，配置时排除敏感数据：  
  ```js
  // userStore配置
  export const useUserStore = defineStore('user', {
    state: () => ({ /* ... */ }),
    actions: { /* ... */ },
    persist: {
      key: 'user-store',
      storage: localStorage,
      paths: ['isLogin', 'userInfo.id', 'userInfo.name'] // 只持久化非敏感字段
    }
  });
  ```
  敏感数据（如用户手机号、Token）：手机号存在`userInfo.phone`，不加入`paths`，不持久化；Token单独存在localStorage，且用“简单加密”（如Base64编码，虽然不是强加密，但避免明文存储，项目需求是PC端租赁网站，无高安全级别要求，若有需要可升级为AES加密）；  
- 路由优化细节：  
  1. keep-alive与导航守卫：在`router/index.js`中配置“需要缓存的页面”（如商品列表页），用`beforeEach`做登录拦截：  
     ```js
     // 路由配置
     const routes = [
       {
         path: '/goods',
         component: GoodsList,
         meta: { keepAlive: true, requiresAuth: false } // 缓存，无需登录
       },
       {
         path: '/order',
         component: OrderList,
         meta: { keepAlive: true, requiresAuth: true } // 缓存，需登录
       }
     ];
     
     // 登录拦截
     router.beforeEach((to, from, next) => {
       const { requiresAuth } = to.meta;
       const isLogin = useUserStore().isLogin;
       if (requiresAuth && !isLogin) {
         next('/login?redirect=' + to.path); // 跳登录页，带回调地址
       } else {
         next();
       }
     });
     ```
  2. scrollBehavior定制：重写`scrollBehavior`，实现“返回上一页时恢复滚动位置”，且“进入商品详情页时滚动到顶部”：  
     ```js
     router.scrollBehavior((to, from, savedPosition) => {
       if (savedPosition && to.meta.keepAlive) {
         return savedPosition; // 缓存页面恢复滚动位置
       }
       return { top: 0 }; // 其他页面滚动到顶部
     });
     ```
  3. 导航吸顶实现：监听`window.scroll`事件，防抖100ms，判断滚动距离是否大于导航高度（80px）：  
     ```js
     const navRef = ref(null);
     const isFixed = ref(false);
     onMounted(() => {
       const handleScroll = debounce(() => {
         const navHeight = navRef.value.offsetHeight; // 80px
         isFixed.value = window.scrollY > navHeight;
       }, 100);
       window.addEventListener('scroll', handleScroll);
       onUnmounted(() => window.removeEventListener('scroll', handleScroll));
     });
     ```
     然后用`:class="{ 'fixed-top': isFixed }"`控制导航样式，fixed时加`z-index: 999`避免被覆盖。

#### 4. 全栈联调的典型问题（跨域）
**回答**：联调时遇到的核心问题是“前端本地（http://localhost:3000）请求后端接口（http://localhost:4000）报跨域错误”，具体解决过程：  
- **问题现象**：前端调用`/api/goods`接口时，Chrome控制台报错“Access to XMLHttpRequest at 'http://localhost:4000/api/goods' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.”；  
- **定位过程**：① 先用Apifox测试后端接口（直接请求http://localhost:4000/api/goods），能正常返回数据，排除后端接口本身问题；② 查看Network面板的“Response Headers”，发现没有`Access-Control-Allow-Origin`字段，确认是跨域问题（浏览器同源策略限制）；  
- **解决方案**：后端用`cors`中间件配置跨域，Express代码如下：  
  ```js
  const express = require('express');
  const cors = require('cors');
  const app = express();
  
  // 配置cors，允许前端域名
  app.use(cors({
    origin: 'http://localhost:3000', // 前端本地域名
    credentials: true, // 允许携带Cookie（用于刷新令牌）
    methods: ['GET', 'POST', 'PUT', 'DELETE'], // 允许的请求方法
    allowedHeaders: ['Content-Type', 'Authorization'] // 允许的请求头
  }));
  
  // 其他路由配置...
  app.listen(4000);
  ```
- **后续优化**：上线前将`origin`改为生产环境域名（如`https://zukehang.com`），避免允许所有域名（`origin: '*'`）的安全风险；同时前端Axios配置`withCredentials: true`，确保Cookie能正常传递（用于刷新令牌）；  
- **结果**：跨域问题解决，前端能正常请求后端接口，联调效率提升——原本卡2小时的问题，10分钟内定位并解决，后续联调未再出现跨域相关错误。


### 五、通用能力与技术规划
#### 1. 未实践但深入研究的性能优化方案（SSR）
**回答**：除了简历中提到的优化手段，我深入研究过“SSR（服务端渲染）”，尤其是基于Nuxt.js（Vue3生态的SSR框架）的方案，适合“首屏加载要求高”的场景（如租赁网站的商品首页，SEO需求+首屏快）：  
- 核心优势：解决“SPA首屏白屏”问题——SPA是客户端渲染，需要加载JS后再渲染页面，首屏慢；SSR是服务端先渲染出完整HTML，发给客户端后直接展示，首屏加载时间可减少50%+，同时有利于SEO（搜索引擎能抓取到完整内容，SPA的空HTML不利于SEO）；  
- 研究细节：做了“租客行商品首页的Nuxt.js Demo”，核心步骤：① 用`nuxi init zukehang-ssr`创建Nuxt3项目；② 在`pages/index.vue`中用`asyncData`钩子（Nuxt3中是`useAsyncData`）在服务端请求商品列表数据；③ 服务端渲染出带商品数据的HTML，客户端接收后激活为SPA（ hydration 过程）；  
- 关键难点：① 服务端无window对象，需避免在服务端执行DOM操作（如之前的`v-lazy-img`指令，需在`client-only`组件中使用）；② 数据共享——服务端请求的数据要传给客户端，避免客户端重复请求（Nuxt.js的`useAsyncData`会自动处理数据脱水/注水）；  
- 未来落地：若项目需要提升首屏速度和SEO，可将商品首页、登录页等核心页面改为SSR，其他页面保留SPA，兼顾性能和开发效率。

#### 2. 老项目（Vue2+Vuex）改造三步法
**回答**：我会按“先规范→再性能→最后迁移”的优先级改造，每步目标明确，避免风险：  
- 第一步：统一代码规范（1-2周），解决“混乱问题”：  
  ① 搭建ESLint+Prettier+Husky工作流（复用之前的配置经验），先跑`eslint --fix`自动修复可修复的问题（如缩进、引号），再手动处理复杂问题（如未使用变量）；  
  ② 梳理Vue2组件规范（如组件名PascalCase、Props定义加类型验证），写《改造规范文档》，团队同步后，新代码按规范写，老代码逐步迭代；  
  ③ 用`vue-inspector`排查“未注册的组件”“重复定义的变量”等隐性问题，减少后续改造风险；  
- 第二步：性能优化（2-3周），解决“瓶颈问题”：  
  ① 用Chrome Performance和Lighthouse做性能 baseline（基准测试），定位瓶颈（如首屏加载慢、列表卡顿）；  
  ② 优化首屏：拆分大组件、懒加载路由（Vue2用`() => import('xxx.vue')`）、压缩静态资源；  
  ③ 优化列表：若有长列表，引入`vue-virtual-scroller`实现虚拟列表（类似之前数据大屏的方案），减少DOM节点；  
  ④ 优化Vuex：拆分冗余的store模块，避免“一个模块管理所有状态”，用`mapState/mapActions`减少重复代码；  
- 第三步：技术栈迁移（4-6周），分模块迁移，降低风险：  
  ① 先升级依赖：Vue2→Vue3（用`@vue/compat`兼容包，允许Vue2和Vue3语法共存），Vuex→Pinia（Pinia兼容Vue2，可先替换Vuex，再升级Vue3）；  
  ② 分模块迁移组件：先迁移“非核心组件”（如弹窗组件、工具组件），再迁移“核心模块”（如商品列表、订单模块），每个模块迁移后做单元测试（用Jest+Vue Test Utils）；  
  ③ 最后移除兼容包：所有组件迁移完成后，删除`@vue/compat`，全面使用Vue3语法（如`<script setup>`、`ref/reactive`）；  
- 核心原则：“小步快跑，频繁测试”——每完成一步就做测试，避免一次性大改造导致项目瘫痪，同时保留回滚方案（如迁移前备份代码）。

#### 3. 6-12个月技术学习规划
**回答**：我的规划围绕“深化Vue3生态+拓展前端工程化”，分三个阶段落地：  
- 阶段1（1-3个月）：深入Vue3源码与进阶特性，目标“能解决复杂场景问题”：  
  ① 学习内容：Vue3响应式原理（`Proxy` vs `Object.defineProperty`）、`setup`语法糖进阶、自定义Hooks设计（如封装更通用的`useTable`、`useForm` Hooks）、Vue3编译优化（如`hoistStatic`静态提升）；  
  ② 落地方式：看Vue官方文档（《Vue.js设计与实现》书籍），做“源码解读笔记”，每月实现1个Demo（如“基于Vue3的可拖拽表格组件”），上传GitHub；  
- 阶段2（4-8个月）：学习前端工程化，目标“能搭建企业级项目工程”：  
  ① 学习内容：Monorepo（用pnpm workspace管理多包项目，适合组件库/工具库开发）、CI/CD（用GitHub Actions实现“提交代码→自动测试→自动部署”）、Docker（前端项目容器化，解决“开发/生产环境不一致”问题）；  
  ② 落地方式：搭建个人Monorepo项目，包含“通用组件库”“工具函数库”两个包，用GitHub Actions配置CI/CD，实现“push代码后自动打包、发布npm包”；  
- 阶段3（9-12个月）：拓展跨端能力，目标“能开发多端应用”：  
  ① 学习内容：Taro（基于Vue3的跨端框架，可开发小程序、H5、App）、小程序开发（微信小程序+支付宝小程序）；  
  ② 落地方式：将“租客行”项目扩展为“多端应用”，开发微信小程序版本，实现“扫码登录PC端”“小程序查看订单”功能，沉淀跨端开发经验；  
- 验证方式：每月写技术博客（发布在掘金/知乎），分享学习成果（如“Vue3自定义Hooks设计实践”“Monorepo项目搭建指南”），同时参与开源项目（如给Vue生态的库提PR），检验学习效果。


以上回答既结合了你的简历经历，又拓展了技术细节和思考过程，能充分展示你的实践能力和知识深度。如果面试中遇到更细节的追问（比如某个技术的具体代码实现、项目中的意外问题处理），可以基于这个框架进一步补充~
