// 函数的作用域定义由定义位置决定，即使foo函数在bar函数内部被调用，
// 它仍然只能访问自己定义时所处作用域（全局作用域）中的变量，而无法访问调用它的函数bar函数中的局部变量
// 语法作用域（静态作用域）：函数的作用域在函数定义时就确定了，而不是在函数调用时确定的

let x = 10; // 全局变量 x

// 函数 foo 定义在全局作用域，[[Scope]] 引用全局
function foo() {
  console.log(x); // 查找 x 时，作用域链：foo → 全局
}

// 函数 bar 定义在全局，内部有局部变量 x=20
function bar() {
  let x = 20;
  foo(); // 调用 foo，但 foo 的作用域链与 bar 无关
}


bar(); // 输出 10（而非 20）




// 1. 代码定义阶段
// ```
// let x = 10; // 全局变量 x

// function foo() {  // 定义在全局作用域
//   console.log(x);
// }

// function bar() {  // 定义在全局作用域
//   let x = 20;
//   foo();
// }
// ```
// - foo 函数定义在全局作用域，其 [[Scope]] 属性引用全局作用域
// - bar 函数定义在全局作用域，其 [[Scope]] 属性也引用全局作用域 2. bar() 调用阶段
// ```
// bar(); // 调用 bar 函数
// ```
// - 创建 bar 函数的执行上下文
// - 在 bar 的执行上下文中创建局部变量 x = 20
// - 执行 foo() 调用 3. foo() 调用阶段
// ```
// function foo() {
//   console.log(x); // 查找 x
// }
// ```
// - 创建 foo 函数的执行上下文
// - foo 函数的作用域链由两部分组成：
//   1. 1.
//      foo 函数自身的活动对象（没有局部变量 x ）
//   2. 2.
//      foo 函数 [[Scope]] 引用的全局作用域（包含 x = 10 ）
// - 当 console.log(x) 执行时，JavaScript引擎按照作用域链查找 x ：
//   - 首先在 foo 函数的活动对象中查找，未找到
//   - 然后沿着作用域链向上查找，在全局作用域中找到 x = 10
//   - 因此输出 10 ，而不是 bar 函数中的局部变量 x = 20