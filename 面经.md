

# HTTP 缓存

HTTP 缓存是浏览器或代理服务器对已请求资源的暂存机制，目的是减少重复请求、提升加载速度，分为**强缓存**和**协商缓存**：



- **强缓存**：直接从本地缓存读取，不发送请求到服务器。
  - 依赖响应头 `Expires`（HTTP/1.0，绝对时间）或 `Cache-Control`（HTTP/1.1，相对时间，如 `max-age=3600` 表示缓存 1 小时）。
  - 若资源未过期，浏览器直接使用本地缓存（状态码：200 OK (from cache)）。
- **协商缓存**：缓存过期后，浏览器发送请求到服务器，由服务器判断是否使用缓存。
  - 依赖请求头 `If-Modified-Since` 与响应头 `Last-Modified`（基于修改时间），或 `If-None-Match` 与 `ETag`（基于资源哈希值）。
  - 若资源未修改，服务器返回 304 Not Modified，浏览器使用本地缓存；否则返回新资源（200 OK）。



**应用场景**：静态资源（图片、CSS、JS）适合强缓存 + 协商缓存结合，通过文件名加哈希（如 `app.123.js`）实现更新时失效。

HTTP 缓存是浏览器 / 代理服务器对资源的暂存机制，目的是减少重复请求，分为**强缓存**和**协商缓存**：

## 强缓存

- **定义**：直接从本地缓存读取资源，不发送请求到服务器，由浏览器自主判断是否使用缓存。

- 控制字段：

  - `Expires`（HTTP/1.0）：响应头中的绝对时间（如`Expires: Wed, 20 Jul 2024 12:00:00 GMT`），若当前时间早于该时间，使用缓存；
  - `Cache-Control`（HTTP/1.1，优先级更高）：相对时间（如`max-age=3600`表示缓存 1 小时），或`no-cache`（禁用强缓存，需协商缓存）、`no-store`（不缓存任何资源）。
  
- **状态码**：命中时返回`200 OK (from memory cache/disk cache)`。

## 协商缓存

- **定义**：强缓存过期后，浏览器发送请求到服务器，由服务器判断是否使用缓存（返回 304 则复用缓存，200 则返回新资源）。

- 验证方式：

  - 基于修改时间：

    - 响应头`Last-Modified`：资源最后修改时间（如`Last-Modified: Tue, 19 Jul 2024 08:00:00 GMT`）；
    - 请求头`If-Modified-Since`：浏览器发送上次的`Last-Modified`值，服务器对比：若资源未修改，返回 304；否则返回 200 + 新资源 + 新`Last-Modified`。
    
  - 基于资源哈希：
  
    - 响应头`ETag`：资源内容的唯一哈希值（如`ETag: "abc123"`）；
  - 请求头`If-None-Match`：浏览器发送上次的`ETag`值，服务器对比：哈希一致则 304，否则 200 + 新资源 + 新`ETag`。
  
- **状态码**：命中时返回`304 Not Modified`，未命中返回`200 OK`。

## 应用场景

- 强缓存：适用于长期不变的静态资源（如图片、库文件），通过`Cache-Control: max-age=31536000`设置 1 年缓存，结合文件名哈希（如`logo.abc.png`）确保更新时失效；
- 协商缓存：适用于频繁更新但不实时的资源（如首页 HTML、API 数据），通过`ETag`或`Last-Modified`减少重复传输。

# localStorage 和 sessionStorage 区别

两者均为 HTML5 本地存储 API，用于在浏览器端存储键值对数据，区别如下：



| 特性           | localStorage                  | sessionStorage                               |
| -------------- | ----------------------------- | -------------------------------------------- |
| **生命周期**   | 永久存储，除非手动删除        | 仅在当前会话（标签页）有效，关闭标签页后清除 |
| **作用域**     | 同域名下所有标签页 / 窗口共享 | 仅当前标签页 / 窗口独立，不共享              |
| **存储大小**   | 约 5MB                        | 约 5MB                                       |
| **数据持久化** | 刷新页面 / 重启浏览器后仍存在 | 刷新页面后存在，关闭标签页后消失             |



**使用场景**：

- localStorage：存储长期有效的数据（如用户偏好设置、登录状态令牌）。
- sessionStorage：存储临时会话数据（如表单临时输入、单页应用的临时状态）。





# CSS 居中方案

根据元素类型（块级 / 行内、定宽 / 不定宽），常用居中方案如下：

## 水平居中

- **行内元素**：父元素设置 `text-align: center`。
- **块级元素（定宽）**：`margin: 0 auto`。
- **块级元素（不定宽）**：父元素用 Flexbox（`display: flex; justify-content: center`）。

## 垂直居中

- **行内元素（单行文本）**：父元素设置 `line-height` 等于高度。

- 块级元素：

  - Flexbox（推荐）：父元素 `display: flex; align-items: center`。
- 定位：父元素 `position: relative`，子元素 `position: absolute; top: 50%; transform: translateY(-50%)`。

## 水平垂直居中

- Flexbox：`display: flex; justify-content: center; align-items: center`。
- Grid：父元素 `display: grid; place-items: center`。





# 输入 URL 后完整渲染过程

1. **DNS 解析**：将域名（如 `baidu.com`）解析为 IP 地址（如 `180.101.50.242`）。
2. **建立连接**：通过 TCP 三次握手与服务器建立连接，HTTPS 还需 TLS 握手协商加密。
3. **发送请求**：浏览器发送 HTTP 请求（包含请求头、方法、路径等）。
4. **服务器响应**：服务器处理请求，返回 HTTP 响应（包含状态码、响应头、HTML 内容）。
5. **断开连接**：TCP 四次挥手关闭连接。
6. **HTML 解析**：浏览器解析 HTML，生成 DOM 树（文档对象模型）。
7. **CSS 解析**：解析 CSS 样式，生成 CSSOM 树（CSS 对象模型）。
8. **构建渲染树**：结合 DOM 树和 CSSOM 树，生成渲染树（只包含可见元素）。
9. **布局（Layout）**：计算渲染树中元素的位置和大小（回流 / 重排）。
10. **绘制（Paint）**：根据布局结果，绘制元素的颜色、背景等（重绘）。
11. **合成（Composite）**：将绘制结果合成到屏幕上，显示最终页面。





# HashMap、链表、二叉树的特点及使用场景

## HashMap（哈希表）

- **特点**：基于哈希函数实现，通过键（Key）直接访问值（Value），平均查找时间复杂度为 O (1)；无序存储，键唯一。
- **使用场景**：需要快速查找、插入、删除的场景（如缓存、字典、用户信息存储）。

## 链表

- **特点**：节点通过指针 / 引用连接，内存不连续；插入 / 删除效率高（O (1)），但查找效率低（O (n)）；分为单向链表、双向链表、循环链表。
- **使用场景**：频繁插入 / 删除且无需随机访问的场景（如队列、栈、LRU 缓存淘汰策略）。

## 二叉树（以二叉搜索树为例）

- **特点**：每个节点最多有两个子节点，左子树值 <根节点值 < 右子树值；查找、插入、删除时间复杂度为 O (log n)（平衡时），最坏 O (n)（不平衡时）。
- **使用场景**：需要有序数据且频繁查找的场景（如数据库索引、排序树）；平衡二叉树（如红黑树）可避免极端情况，用于 TreeMap 等。





#  Vue 双向绑定的实现原理（Vue 3）

Vue 双向绑定（`v-model`）本质是**数据驱动视图 + 视图反馈数据**的联动机制，核心依赖**响应式系统**和**事件监听**：



1. **响应式系统（数据 → 视图）**：
   - Vue 3 使用 `Proxy` 代理数据对象，拦截数据的读取（`get`）和修改（`set`）。
   - 当组件渲染时，访问数据会触发 `get` 拦截，收集依赖（当前组件的渲染函数）。
   - 当数据修改时，触发 `set` 拦截，通知所有依赖的组件重新渲染（视图更新）。
2. **事件监听（视图 → 数据）**：
   - `v-model` 本质是语法糖，为表单元素（如 `input`）绑定 `input` 事件（或其他事件，如 `change`）。
   - 当用户在视图中输入内容时，触发事件回调，修改对应的数据（数据更新）。

**示例**：

vue

```vue
<input v-model="message">
<!-- 等价于 -->
<input :value="message" @input="message = $event.target.value">
```



- 数据 `message` 变化时，`value` 随响应式系统自动更新（数据 → 视图）。
- 用户输入时，`input` 事件触发，`message` 被重新赋值（视图 → 数据）。

#  JavaScript 事件循环（Event Loop）机制

JS 是单线程语言，通过事件循环实现非阻塞异步操作，核心流程如下：



1. **调用栈（Call Stack）**：执行同步代码，函数调用入栈，执行完出栈。

2. **Web API**：遇到异步任务（如 `setTimeout`、`fetch`、DOM 事件），交给浏览器内核处理（计时、网络请求等）。

3. 任务队列（Task Queue）：异步任务完成后，回调函数进入队列（分为宏任务和微任务）：

   - 宏任务（Macro Task）：`setTimeout`、`setInterval`、DOM 事件、`script` 整体代码。
   - 微任务（Micro Task）：`Promise.then/catch/finally`、`async/await`、`queueMicrotask`。
   
4. 事件循环：

   - 调用栈为空时，优先执行**所有微任务**（清空微任务队列）。
- 微任务执行完后，执行**一个宏任务**，然后再次检查微任务队列，循环往复。



**示例**：

javascript

```javascript
console.log('1'); // 同步代码，直接执行
setTimeout(() => console.log('2'), 0); // 宏任务，进入队列
Promise.resolve().then(() => console.log('3')); // 微任务，进入队列
console.log('4'); // 同步代码，直接执行

// 输出顺序：1 → 4 → 3 → 2
```

- 同步代码先执行（1、4）。
- 调用栈空后，执行所有微任务（3）。
- 最后执行一个宏任务（2）。

# 浏览器访问链接全过程

从用户输入 URL 到页面显示，完整流程可分为 7 个核心步骤：

1. **URL 解析与校验**
   浏览器首先校验 URL 格式（如是否包含协议`http/https`），若缺失则自动补全（如输入`baidu.com`补全为`https://baidu.com`），并分离出协议、域名、端口、路径等信息。
2. **DNS 域名解析**
   将域名（如`baidu.com`）转换为服务器 IP 地址（如`180.101.50.242`），流程为：
   - 检查浏览器缓存 → 系统缓存（如`hosts`文件） → 路由器缓存 → DNS 服务器（本地 DNS → 根 DNS → 顶级域名 DNS → 权威 DNS）。
   - 解析结果会被缓存（TTL 过期前复用）。
3. **建立 TCP 连接（三次握手）**
   浏览器与目标服务器通过 TCP 协议建立连接：
   - 客户端发送 “连接请求”（SYN）；
   - 服务器回复 “同意连接”（SYN+ACK）；
   - 客户端确认 “连接建立”（ACK）。
     （若为 HTTPS，还需额外进行 TLS 握手：协商加密算法、交换证书、生成会话密钥，确保数据传输加密）。
4. **发送 HTTP 请求**
   浏览器构造 HTTP 请求报文（包含请求行：`GET /index.html HTTP/1.1`；请求头：`Host、User-Agent、Cookie`等；请求体：POST 请求时携带数据），通过 TCP 连接发送给服务器。
5. **服务器处理请求并返回响应**
   - 服务器接收请求，解析路径、参数等，执行后端逻辑（如查询数据库、渲染页面）；
   - 生成 HTTP 响应报文（包含状态码：如`200 OK`；响应头：`Content-Type、Cache-Control`等；响应体：HTML/CSS/JS 等资源），返回给浏览器。
6. **关闭 TCP 连接（四次挥手）**
   数据传输完成后，双方通过四次挥手断开连接（确保数据完整传输）。
7. **页面渲染**
   浏览器解析响应内容，执行渲染流程：
   - 解析 HTML 生成 DOM 树 → 解析 CSS 生成 CSSOM 树 → 合并为渲染树 → 布局（计算元素位置大小） → 绘制（填充颜色 / 背景） → 合成（图层合并显示）。





# 页面框架加载优化

针对前端框架（如 Vue/React）的加载优化，核心是**减少资源体积、加速资源获取、优化渲染效率**，常见策略：



1. **资源压缩与合并**
   - 代码压缩：使用`terser`压缩 JS，`cssnano`压缩 CSS，移除空格、注释、未使用代码（Tree-Shaking）；
   - 图片优化：使用 WebP/AVIF 格式（体积比 JPG 小 30%+），根据设备尺寸加载不同分辨率图片（响应式图片）；
   - 合并请求：通过 HTTP/2 多路复用（同一连接并发请求）减少 TCP 握手开销，或合理合并小资源（如精灵图）。
2. **懒加载与预加载**
   - 懒加载：非首屏资源（如图片、组件）延迟加载（监听`scroll`事件或使用`IntersectionObserver`），减少初始加载压力；
   - 预加载：关键资源（如首屏 JS/CSS）通过`<link rel="preload">`提前加载，`rel="prefetch"`预加载未来可能用到的资源（如跳转页面的 JS）。
3. **缓存策略**
   - 强缓存：对静态资源（JS/CSS/ 图片）设置`Cache-Control: max-age=31536000`（长期缓存），结合文件名哈希（如`app.8f2d.js`）确保更新时失效；
   - 协商缓存：对频繁更新的资源（如 API 数据）使用`ETag/Last-Modified`，减少重复传输。
4. **代码分割与按需加载**
   - 框架路由级分割：使用`React.lazy`/`Vue异步组件`，按路由拆分代码，只加载当前页面所需 JS；
   - 库分离：通过`webpack`/`vite`将第三方库（如`lodash`）与业务代码分离，利用长期缓存。
5. **渲染优化**
   - 减少 DOM 操作：使用虚拟 DOM（框架自带），避免频繁回流 / 重绘（如批量修改样式、使用`documentFragment`）；
   - 优化首屏渲染：服务端渲染（SSR）或静态站点生成（SSG），直接返回 HTML 减少客户端渲染时间；
   - 避免阻塞资源：对非关键 JS 使用`async`/`defer`（不阻塞 HTML 解析），非关键 CSS 使用`media="print"`（不阻塞渲染）。
6. **CDN 加速**
   将静态资源部署到 CDN（内容分发网络），用户从最近的节点获取资源（减少物理距离延迟），同时 CDN 节点自带缓存，进一步加速访问。



# 跨域是什么

跨域是指**浏览器因 “同源策略” 限制，阻止不同源的页面之间进行数据交互**的现象。

- **同源定义**：两个 URL 的**协议、域名、端口**必须完全一致，否则为跨域。
  例：`https://a.com:8080` 与 `https://b.com`（域名不同）、`http://a.com`（协议不同）、`https://a.com:8081`（端口不同）均为跨域。
- **同源策略目的**：保护用户数据安全，防止恶意网站窃取其他网站的 Cookie、LocalStorage 等敏感信息。
- **跨域场景**：
  - 前端页面（`http://localhost:3000`）调用后端 API（`http://localhost:5000`）；
  - 嵌入第三方网站的 iframe 中，父页面与子页面通信。
- **解决方法**：
  - **CORS（跨域资源共享）**：后端在响应头中设置`Access-Control-Allow-Origin: http://localhost:3000`，允许指定源访问；
  - **代理服务器**：前端通过本地服务器（如 Webpack Dev Server）代理请求（同源下转发到跨域服务器）；
  - **JSONP**：利用`<script>`标签不受同源限制的特性，后端返回回调函数包裹的数据（仅支持 GET 请求）；
  - **其他**：iframe+`postMessage`（页面间通信）、WebSocket（全双工通信，不受同源限制）。





# 数组和链表的随机查找、插入删除的时间复杂度

| 操作             | 数组（Array）     | 链表（Linked List） | 原因分析                                                     |
| ---------------- | ----------------- | ------------------- | ------------------------------------------------------------ |
| **随机查找**     | O(1)              | O(n)                | 数组内存连续，通过索引直接访问（如`arr[3]`）；链表内存分散，需从表头遍历到目标节点。 |
| **插入（头）**   | O(n)              | O(1)                | 数组需移动所有元素（如`[1,2,3]`插在头部→`[0,1,2,3]`）；链表只需修改头节点指针。 |
| **插入（尾）**   | O (1)（预留空间） | O(n)                | 数组若有预留空间，直接添加；链表需遍历到尾节点（双向链表可优化为 O (1)）。 |
| **插入（中间）** | O(n)              | O(n)                | 数组需移动插入位置后所有元素；链表需先遍历到插入位置（修改指针 O (1)，但查找 O (n)）。 |
| **删除（头）**   | O(n)              | O(1)                | 数组需移动所有元素；链表只需修改头节点指针。                 |
| **删除（尾）**   | O(1)              | O(n)                | 数组直接删除；链表需遍历到尾节点前一个节点（双向链表可优化为 O (1)）。 |
| **删除（中间）** | O(n)              | O(n)                | 数组需移动删除位置后所有元素；链表需先遍历到删除位置（修改指针 O (1)，但查找 O (n)）。 |



# MySQL 写入锁

MySQL 中的写入锁（Write Lock，简称 “写锁”）是**表级锁或行级锁的一种，用于控制数据写入时的并发访问**，核心特点：

- **作用**：保证数据一致性，防止多个事务同时修改同一资源导致冲突。
- **锁特性**：
  - 写锁是排他锁（X 锁）：一旦某事务获取写锁，其他事务**既不能获取读锁，也不能获取写锁**，需等待写锁释放；
  - 写锁释放：事务提交（`COMMIT`）或回滚（`ROLLBACK`）时释放。
- **适用场景**：
  - 表级写锁：使用`LOCK TABLES table WRITE`手动加锁，适用于全表更新（如批量修改），但会阻塞全表读写，性能低，不常用；
  - 行级写锁：InnoDB 引擎默认开启，通过索引对修改的行加锁（如`UPDATE users SET name='a' WHERE id=1`会锁定`id=1`的行），仅阻塞该行的读写，并发性能高，是 MySQL 默认的写锁方式。
- **影响**：合理使用写锁可避免 “脏写”（多个事务覆盖彼此的修改），但过度加锁会导致 “死锁”（如事务 A 锁行 1 等行 2，事务 B 锁行 2 等行 1），需通过合理设计索引、减少事务持有锁时间避免。



# 项目中遇到的性能问题及解决方法

在实际项目中，性能问题通常体现在**加载慢、渲染卡、交互延迟**等方面，具体解决思路如下：

## 页面加载缓慢

- **问题表现**：首屏加载时间过长（超过 3 秒），白屏时间久。
- 解决方法
  - 资源优化
    - 压缩 JS/CSS（使用`terser`、`cssnano`），图片转 WebP/AVIF 格式并压缩，移除未使用代码（Tree-Shaking）；
    - 路由懒加载（如 Vue 的`() => import('./Page.vue')`），只加载当前页面所需代码；
    - 第三方库按需引入（如从`lodash`只导入`debounce`而非全量引入）。
  - 缓存策略
    - 静态资源（JS/CSS/ 图片）设置强缓存（`Cache-Control: max-age=31536000`），结合文件名哈希确保更新有效；
    - 接口数据使用协商缓存（`ETag`/`Last-Modified`）或本地缓存（`localStorage`）减少重复请求。
  - 网络优化
    - 使用 CDN 分发静态资源，减少物理距离延迟；
    - 启用 HTTP/2 多路复用（同一连接并发请求），减少 TCP 握手开销。

## 渲染卡顿（掉帧）

- **问题表现**：滚动、动画时页面卡顿，帧率低于 60fps。
- 解决方法
  - 减少回流 / 重绘
    - 批量修改 DOM（如用`documentFragment`一次性插入多个元素）；
    - 避免频繁读取`offsetTop`、`scrollHeight`等触发回流的属性（可缓存结果）；
    - 将动画元素设为`will-change: transform`或`transform: translateZ(0)`，触发 GPU 加速（图层隔离）。
  - 优化渲染树
    - 移除不可见元素（如`display: none`），减少渲染树节点；
    - 避免嵌套过深的 DOM 结构（CSS 选择器解析复杂度随层级增加而上升）。

## 交互响应延迟

- **问题表现**：点击、输入等操作反馈慢（超过 100ms）。
- 解决方法
  - 减少主线程阻塞
    - 将复杂计算（如大数据排序）放入`Web Worker`（避免阻塞 UI 线程）；
    - 防抖（`debounce`）处理高频事件（如`resize`、`scroll`），限制触发频率。
  - 优化事件处理
    - 对列表项使用事件委托（将事件绑定到父元素，而非每个子元素）；
    - 避免在`scroll`、`mousemove`等实时事件中执行重计算或 DOM 操作。



# CSS 实现动画的两种核心方式（transition、keyframes）

CSS 动画用于实现元素的状态变化（如位移、缩放、颜色过渡等），核心方式有两种：

## `transition`：过渡动画（适合简单状态切换）

- **作用**：使元素从一个样式状态平滑过渡到另一个状态（如 hover 时的颜色变化、宽度调整）。
- **核心属性**：
  - `transition-property`：指定过渡的 CSS 属性（如`width`、`background-color`，`all`表示所有属性）；
  - `transition-duration`：过渡持续时间（如`0.3s`）；
  - `transition-timing-function`：过渡速度曲线（如`ease`、`linear`、`ease-in-out`）；
  - `transition-delay`：延迟开始时间（如`0.1s`）。
- **简写语法**：`transition: property duration timing-function delay`。
- **示例**：按钮 hover 时平滑变色并放大

css

```css
.btn {
  width: 100px;
  height: 40px;
  background: #42b983;
  /* 过渡：所有属性，0.3秒，ease曲线 */
  transition: all 0.3s ease;
}

.btn:hover {
  background: #35945d; /* 颜色变化 */
  transform: scale(1.1); /* 放大1.1倍 */
}
```

## `@keyframes` + `animation`：关键帧动画（适合复杂多阶段动画）

- **作用**：定义多个关键帧（状态），实现更精细的动画控制（如循环旋转、多步位移）。
- **使用步骤**：
  1. 用`@keyframes`定义动画序列（关键帧）；
  2. 用`animation`属性将动画应用到元素。
- **`@keyframes`语法**：

css

```css
@keyframes 动画名称 {
  0% { /* 初始状态 */ }
  50% { /* 中间状态 */ }
  100% { /* 结束状态 */ }
}
```



- **`animation`核心属性**：
  - `animation-name`：绑定的`@keyframes`动画名称；
  - `animation-duration`：动画持续时间（如`2s`）；
  - `animation-timing-function`：速度曲线（同`transition`）；
  - `animation-iteration-count`：播放次数（`infinite`表示无限循环）；
  - `animation-direction`：播放方向（`normal`正向、`reverse`反向、`alternate`交替）；
  - `animation-fill-mode`：动画结束后保持的状态（`forwards`保持最后一帧）。
- **示例**：元素循环旋转并变色

css

```css
/* 定义关键帧动画 */
@keyframes rotateAndChange {
  0% {
    transform: rotate(0deg);
    background: red;
  }
  50% {
    transform: rotate(180deg);
    background: blue;
  }
  100% {
    transform: rotate(360deg);
    background: red;
  }
}

.box {
  width: 100px;
  height: 100px;
  /* 应用动画：名称2秒ease曲线，无限循环，交替方向 */
  animation: rotateAndChange 2s ease infinite alternate;
}
```



# 渲染大量元素（10000+）的解决方案

当需要渲染一万个以上元素时，直接插入 DOM 会导致**渲染树过大、回流频繁**，造成页面卡顿甚至崩溃。需根据 “是否同时显示所有元素” 采用不同策略：

## 需同时显示所有元素：优化 DOM 操作与渲染

- **核心思路**：减少 DOM 节点创建 / 插入的性能开销，避免频繁回流。

- **方案 1：使用`DocumentFragment`批量插入**
  `DocumentFragment`是一个虚拟 DOM 节点容器，可先将所有元素添加到其中，最后一次性插入页面，**只触发 1 次回流**（而非 10000 次）。

  javascript

  ```javascript
  const fragment = document.createDocumentFragment(); // 创建虚拟容器
  for (let i = 0; i < 10000; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    fragment.appendChild(div); // 先添加到虚拟容器（无回流）
  }
  document.body.appendChild(fragment); // 一次性插入（仅1次回流）
  ```

- **方案 2：使用 Canvas 绘制（非交互场景）**
  若元素无需交互（如纯展示的大数据列表、图表），可用 Canvas 直接绘制，**避免创建大量 DOM 节点**（Canvas 渲染由 GPU 加速，性能远高于 DOM）。

  javascript

  ```javascript
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');
  ctx.font = '14px Arial';
  
  // 绘制10000行文本
  for (let i = 0; i < 10000; i++) {
    ctx.fillText(`Item ${i}`, 10, 20 + i * 20); // 每行间隔20px
  }
  ```

## 无需同时显示所有元素：虚拟列表（只渲染可视区域）

- **核心思路**：只渲染用户当前可见区域的元素（如屏幕内显示 10 条，只渲染 10 条），滚动时动态替换内容，**DOM 节点数量始终保持在几百以内**。
- **实现原理**：
  1. 计算可视区域高度和单个元素高度，确定可见元素数量（如高度 500px，单个元素 50px → 可见 10 条）；
  2. 监听滚动事件，计算滚动偏移量，确定当前需要显示的元素范围（如滚动到第 100 条，显示 95-105 条）；
  3. 通过`transform: translateY`调整列表容器位置，模拟滚动效果，同时更新 DOM 只保留可见元素。
- **示例代码（简化版）**：

html

预览

```html
<div class="virtual-list" style="height: 500px; overflow: auto;">
  <div class="list-container" id="listContainer">
    <!-- 只渲染可视区域元素 -->
  </div>
</div>

<script>
const total = 10000; // 总数据量
const itemHeight = 50; // 单个元素高度
const container = document.getElementById('listContainer');
const list = document.querySelector('.virtual-list');

// 渲染可视区域元素
function renderVisibleItems() {
  const scrollTop = list.scrollTop; // 滚动偏移量
  const visibleCount = Math.ceil(list.clientHeight / itemHeight); // 可见数量
  const startIndex = Math.floor(scrollTop / itemHeight); // 起始索引
  const endIndex = Math.min(startIndex + visibleCount + 1, total); // 结束索引（多渲染1条避免空白）

  // 清空容器，只渲染可见范围
  container.innerHTML = '';
  // 调整容器位置（模拟滚动）
  container.style.transform = `translateY(${startIndex * itemHeight}px)`;

  // 添加可见元素
  for (let i = startIndex; i < endIndex; i++) {
    const div = document.createElement('div');
    div.style.height = `${itemHeight}px`;
    div.textContent = `Item ${i}`;
    container.appendChild(div);
  }
}

// 初始化渲染 + 监听滚动
renderVisibleItems();
list.addEventListener('scroll', renderVisibleItems);
</script>
```

## 超大数据分批渲染：利用`requestAnimationFrame`

若需渲染的元素必须全部存在于 DOM 中（如需要交互），但数量过大（10 万 +），可采用**分片渲染**：每次渲染一部分，利用浏览器帧间隔（约 16ms）逐步完成，避免阻塞主线程。

javascript

```javascript
const total = 100000;
const batchSize = 500; // 每批渲染500个
let current = 0;

function renderBatch() {
  const fragment = document.createDocumentFragment();
  const end = Math.min(current + batchSize, total);
  
  // 渲染当前批次
  for (let i = current; i < end; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    fragment.appendChild(div);
  }
  document.body.appendChild(fragment);
  current = end;

  // 未完成则继续下一帧渲染
  if (current < total) {
    requestAnimationFrame(renderBatch); // 在下一帧执行（避免阻塞）
  }
}

// 开始渲染
renderBatch();
```

- 渲染大量元素的核心是**减少 DOM 节点数量**和**降低回流频率**；
- 同时显示：用`DocumentFragment`批量插入，或 Canvas 绘制（非交互）；
- 非同时显示：虚拟列表（只渲染可视区域）是最优解；
- 超大数据：用`requestAnimationFrame`分片渲染，避免页面卡顿。



# HTTP1.0、HTTP2.0、HTTP3.0 的区别

HTTP 各版本的核心差异体现在**性能、安全性、传输效率**上，逐步解决了早期版本的瓶颈：



| 特性           | HTTP1.0（1996）                   | HTTP1.1（1999）                       | HTTP2.0（2015）                        | HTTP3.0（2022，基于 QUIC）               |
| -------------- | --------------------------------- | ------------------------------------- | -------------------------------------- | ---------------------------------------- |
| **连接方式**   | 短连接（每次请求需新建 TCP 连接） | 长连接（`Keep-Alive`，复用 TCP 连接） | 多路复用（单一 TCP 连接并发请求）      | 基于 UDP 的 QUIC 协议（无 TCP 队头阻塞） |
| **数据格式**   | 文本格式（易解析但冗余）          | 文本格式                              | 二进制帧（分帧传输，更高效）           | 二进制帧（基于 QUIC 的帧结构）           |
| **队头阻塞**   | 严重（连接未复用，请求串行）      | 存在（管道化请求仍受前序请求阻塞）    | 缓解（多路复用，单请求阻塞不影响其他） | 解决（QUIC 单个流阻塞不影响全局）        |
| **头部压缩**   | 无（重复头部浪费带宽）            | 无                                    | HPACK 算法（字典压缩重复头部）         | QPACK（基于 HPACK 优化，更高效）         |
| **服务器推送** | 无                                | 无                                    | 支持（主动推送关联资源，如 CSS/JS）    | 支持（基于 QUIC 的流推送）               |
| **安全性**     | 无强制加密                        | 无强制加密                            | 推荐 HTTPS（与 TLS 结合更紧密）        | 强制加密（QUIC 内置 TLS 1.3）            |
| **典型场景**   | 早期简单网页（少量请求）          | 常规网页（多资源请求）                | 复杂应用（大量静态资源、API 请求）     | 实时通信（视频、直播）、高并发场景       |

# TCP 和 UDP 的区别；Promise 的三种状态

## TCP 和 UDP 的区别

TCP（传输控制协议）和 UDP（用户数据报协议）是 TCP/IP 协议栈中两种核心传输层协议，差异主要在**可靠性、连接性、效率**：



| 特性         | TCP                                        | UDP                                    |
| ------------ | ------------------------------------------ | -------------------------------------- |
| **连接性**   | 面向连接（三次握手建立连接，四次挥手关闭） | 无连接（直接发送数据，无需建立连接）   |
| **可靠性**   | 可靠（重传丢失数据包、按序交付、流量控制） | 不可靠（不保证送达、无序，无重传机制） |
| **效率**     | 低（握手、确认机制耗时）                   | 高（无额外开销，速度快）               |
| **数据边界** | 无（数据合并成字节流，需应用层处理边界）   | 有（每个数据包独立，保留边界）         |
| **适用场景** | 数据传输（HTTP、文件下载、邮件）           | 实时通信（视频 / 语音通话、直播、DNS） |

## Promise 的三种状态

Promise 是 JavaScript 处理异步操作的对象，有三种不可逆转的状态：



- **pending（进行中）**：初始状态，异步操作未完成。
- **fulfilled（已成功）**：异步操作完成，调用`resolve()`触发，状态固定后不可再变。
- **rejected（已失败）**：异步操作出错，调用`reject()`触发，状态固定后不可再变。

例：

javascript

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (Math.random() > 0.5) {
      resolve("成功"); // 状态从pending→fulfilled
    } else {
      reject("失败"); // 状态从pending→rejected
    }
  }, 1000);
});
```



# 网络安全方面的内容

网络安全核心是保护数据和系统免受未授权访问、攻击或破坏，常见安全问题及防护措施：

## 常见安全威胁

- **XSS（跨站脚本攻击）**：攻击者注入恶意脚本（如`<script>窃取Cookie</script>`），在用户浏览器执行，窃取信息。
- **CSRF（跨站请求伪造）**：攻击者诱导用户在已登录状态下，向目标网站发送伪造请求（如转账、删帖）。
- **SQL 注入**：通过输入恶意 SQL 语句（如`' OR '1'='1`），非法访问或篡改数据库。
- **中间人攻击**：拦截并篡改客户端与服务器的通信（如窃取 HTTPS 未加密的数据）。
- **DDoS 攻击**：通过大量虚假请求耗尽服务器资源，导致服务瘫痪。

## 防护措施

- **XSS 防护**：输入验证（过滤`<script>`等标签）、输出编码（将`<`转义为`<`）、使用 CSP（内容安全策略，限制脚本来源）。
- **CSRF 防护**：使用 Token（如`csrf-token`，每次请求验证）、检查 Referer/Origin（限制请求来源）、SameSite Cookie（阻止跨站发送 Cookie）。
- **SQL 注入防护**：使用参数化查询（Prepared Statement）、ORM 框架（如 MyBatis），避免直接拼接 SQL。
- **数据传输安全**：强制 HTTPS（TLS 加密传输），避免明文传输敏感信息（如密码）。
- **身份认证**：密码加密存储（如 bcrypt 哈希）、多因素认证（密码 + 验证码 / 指纹）、限制登录失败次数。
- **其他**：定期更新系统 / 框架（修复漏洞）、使用防火墙过滤恶意 IP、部署 WAF（Web 应用防火墙）。



# 常见数据库类型及划分区别

数据库按数据模型可分为**关系型数据库**和**非关系型数据库（NoSQL）**，核心区别在数据结构和适用场景：

## 关系型数据库（RDBMS）

- **特点**：基于二维表结构（行 + 列），通过 SQL 查询，支持事务（ACID 特性）、外键关联，数据结构化强。
- **代表**：MySQL、PostgreSQL、Oracle、SQL Server。
- **适用场景**：需要强一致性、结构化数据的场景（如电商订单、银行交易、用户信息）。

## 非关系型数据库（NoSQL）

为解决高并发、非结构化数据场景设计，无固定表结构，不依赖 SQL：



| 类型         | 特点                               | 代表              | 适用场景                             |
| ------------ | ---------------------------------- | ----------------- | ------------------------------------ |
| 键值对数据库 | 以 Key-Value 存储，查询快（O (1)） | Redis、Memcached  | 缓存（如 Session）、计数器、排行榜   |
| 文档型数据库 | 存储 JSON/BSON 文档，结构灵活      | MongoDB、CouchDB  | 内容管理（博客、评论）、非结构化数据 |
| 列族数据库   | 按列存储，适合海量数据查询         | HBase、Cassandra  | 大数据分析（日志、时序数据）         |
| 图数据库     | 存储节点和关系（如社交网络）       | Neo4j、JanusGraph | 关系图谱（好友推荐、路径分析）       |

## 核心区别

| 维度     | 关系型数据库                        | 非关系型数据库                              |
| -------- | ----------------------------------- | ------------------------------------------- |
| 数据结构 | 固定表结构（需预定义 Schema）       | 灵活（无固定 Schema，动态扩展）             |
| 事务支持 | 强（ACID 特性，适合转账等关键操作） | 弱（部分支持，如 MongoDB 的多文档事务）     |
| 扩展性   | 垂直扩展（升级硬件）为主            | 水平扩展（增加节点）为主                    |
| 查询语言 | SQL（标准化，易学）                 | 各数据库自定义 API（如 MongoDB 的查询语法） |



# CDN 加速的原理

CDN（内容分发网络）是通过**全球分布式节点**，让用户从最近的服务器获取资源，减少延迟，核心原理如下：



1. **分布式节点部署**
   CDN 服务商在全球多地（如北美、欧洲、亚洲）部署边缘节点（服务器），这些节点存储静态资源（JS/CSS/ 图片、视频）的缓存副本。
2. **用户请求路由优化**
   - 当用户请求资源（如`https://img.example.com/logo.png`）时，DNS 解析会将请求导向**离用户最近的 CDN 节点**（通过 IP 地址定位用户地理位置）。
   - 若节点缓存了该资源，直接返回给用户（“命中缓存”）；若未缓存，节点会向源服务器（网站的原始服务器）请求资源，缓存后再返回（“回源”）。
3. **核心优化点**
   - **减少物理距离**：用户从本地节点获取资源，避免跨洲际传输的延迟（如中国用户从国内节点获取，而非美国源服务器）。
   - **负载均衡**：CDN 通过算法选择最优节点（如节点负载低、网络通畅），避免单节点压力过大。
   - **边缘缓存**：静态资源（如图片、视频）在节点长期缓存，减少源服务器的请求压力。
   - **动态路由**：实时监控网络状况，避开拥堵链路，选择最快路径传输。

例：用户访问一个美国网站的图片，若该图片已缓存到中国的 CDN 节点，用户直接从中国节点下载，耗时从数百毫秒缩短到几十毫秒。



# 京东前端一面

- 自我介绍
- JS 有几种声明变量的方法？  
- var、let、const 有什么区别？
- 什么是块级作用域？  
-  ES6 之前是否有块级作用域？如何用函数作用域模拟块级作用域？  
-  IIFE 的作用是什么？有什么优缺点？
- Promise 有哪些常用方法？   
- Promise.all 的作用是什么？
- 如果其中一个 Promise 失败，其他 Promise 的结果能否拿到？  
- 如何实现无论成功失败都拿到所有 Promise 的结果？
- Promise.race 的应用场景是什么？
- async/await 和 Promise 的关系？   
- async/await 异常捕获有几种方式？
- await 等待的是什么？
- 为什么 async/await 可以写成同步风格？（生成器的原理）
- for 循环和 forEach 的区别？   
- forEach 能否中断？
- for 循环中修改索引是否有效？
- for 和 forEach 处理异步函数的区别？
- 项目如何解决跨域问题？   
- Nginx 代理的缺点？
- CORS 的完整流程？
- CORS 预检请求（OPTIONS）的作用？   
- 什么情况下会发 OPTIONS 请求？每个跨域请求都会发吗？
- OPTIONS 请求检查哪些内容？
- Flex 布局默认主轴方向？
- flex: 1 的含义？
- flex-basis 可设置哪些值？  
- 同时设置 width 和 flex-basis 哪个优先级高？
- max-width 和 flex-basis 的优先级？
- Vue 的 v-for 是否需要 key？   
- 不设置 key 可能导致什么问题？除了性能问题？为什么数组会渲染错乱
- 能否用 index 作为 key？
- React 函数组件和类组件的区别？   
- useEffect 空依赖数组模拟哪个生命周期？
- useEffect 无依赖数组时执行时机？
- 手写，实现一个 Hook：监听窗口尺寸变化并返回宽高，考虑性能优化



```
// 返回当前窗口的宽度和高度,考虑性能（节流）
const useGetClient = () => {
  const [width, setWidth] = useState(getClient().width);
  const [hight, setHight] = useState(getClient().hight);

  const handleResize = useCallback(
    throttle(() => {
      setWidth(getClient().width);
      setHight(getClient().hight);
    }, 300),
    []
  );

  useEffect(() => {
    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, [handleResize]);

  return {
    width,
    hight,
  };
};

function throttle(fn, delay) {
  let timer = null;

  return function (...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    }
  };
}

```

- 为什么用节流而非防抖？



# 快手前端一面

自我介绍

介绍一下在这个两段实习经历里面所承担的一些工作

遇到的前端性能问题是什么，然后以及是怎么定位的，然后最终是怎么优化的？

轮询的一个原因？有了解 Web SOCKET 的嘛？然后为什么没有用 Web SOCKET？然后以及轮询和 Web SOCKET 的有什么区别？

Web SOCKET是全双工的协议，还是单向的

为什么用 local storage 去做这个持久化？

用浏览器的存储方式的话，还有什么其他的方案能解决这个问题？

如果你用 local storage这些浏览器有缓存能力的话，用户把这个缓存删了怎么办？

localStorage 和 sessionStorage以及 cookie 有啥区别？

Vue3针对Vue2做了哪些优化

原理上有什么区别吗？

proxy 去替代 object 点 define 是为了解决什么问题呢？

Vue 的 diff 算法

用 index 做 key 的话，会出现什么问题呢？

浏览器中的垃圾回收机制

事件循环机制

看代码给出输出顺序（事件循环）

Promise有几种状态？

promise 状态流转依赖啥？

怎么操作会让 promis 就是保持pending的状态，或者是进入成功或失败的状态？

 

算法题：

判断带括号的字符串是否有效



# 美团前端一面

自我介绍

哈希表和二叉树他们提供哪些操作，然后这些操作的一些实现复杂度大概什么样的。

比较一下他们的实际在使用场景上的一个区分

如果这个场景他需要加速的话有什么办法？就二叉树因为它是个 n log n ，需要加速。

能解释下为什么它范围查询是比较快呢？为什么B+树范围查询比较快？

讲事件循环

为什么我们需要微任务机制？

跨域是啥？有哪些解决方案？

之后问了一堆实习巴拉巴拉

你平常遇到bug怎么解决的？

 

算法题：

二叉树层序遍历

删除和排序链表中的重复元素



