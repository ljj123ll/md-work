# 说说JavaScript中的数据类型？存储上的差别？
## 数据类型的划分

### 基本数据类型

**Number**：数值类型包括
整数 let intNum = 55
浮点数 let floatNum = 1.2
NaN（Not a Number）特殊值，用于表示本来要返回数值的操作失败了
Infinity（无穷大）

**String** 字符串类型，由Unicode字符组成，可用单引号和双引号或反引号包裹
**Boolean** 布尔类型，true false
**Null** 空（区分字符串"null"）
**Undefined** 未定义：变量申明后未赋值时的默认值
**Symbol**  唯一且不可变的原始值，用于创建对象的唯一属性键（如 const s = Symbol('id')）
**BigInt（ES2020+）**：用于表示超出 Number 精度范围的大整数，后缀加 n（如 9007199254740993n）



### 引用数据类型（1 种核心类型，衍生多种形式）

引用类型本质上都是 **Object**，但表现为不同的具体形式，包括：

- **普通对象（Object）**：键值对集合（`{ name: 'xxx' }`）。
- **数组（Array）**：有序索引的集合（`[1, 2, 3]`）。
- **函数（Function）**：可执行的代码块（`() => {}` 或 `function() {}`）。
- **日期（Date）**：时间对象（`new Date()`）。
- **正则表达式（RegExp）**：模式匹配工具（`/abc/`）。
- 其他内置对象：如 `Map`、`Set`、`WeakMap`、`WeakSet` 等（ES6+ 新增，用于更高效的数据存储）。

## 存储方式的差异

### 1. 基本类型：存储在「栈内存」中

- **栈内存（Stack）** 是一种线性结构的内存空间，特点是**容量小、访问速度快、自动分配和释放**（遵循 “后进先出” 原则）。
- **存储内容**：基本类型的值直接存储在栈中，且**占用空间固定**（如 Number 固定占 8 字节，Boolean 占 1 字节等）。
- **示例**：
  `const age = 25;`
  栈内存中会直接保存 `25` 这个值，变量 `age` 指向栈中的这个值。

### 2. 引用类型：值存储在「堆内存」，地址存储在「栈内存」

- **堆内存（Heap）** 是一种非线性结构的内存空间，特点是**容量大、访问速度较慢、动态分配和释放**（需手动或垃圾回收机制回收）。
- **存储逻辑**：
  引用类型的值（如对象的键值对、数组的元素）会被存储在堆内存中，而变量在栈内存中仅存储**指向堆内存的地址（指针）**。
  当访问引用类型时，JavaScript 引擎会先从栈中读取地址，再通过地址到堆中找到具体的值。
- **示例**：
  `const user = { name: '张三' };`
  堆内存中存储 `{ name: '张三' }` 这个对象，栈内存中 `user` 变量存储的是指向堆中该对象的地址（如 `0x0012ff7c`）。

## 存储差异导致的关键行为差异

存储方式的不同直接导致了基本类型和引用类型在**复制、比较、参数传递**等行为上的差异：

### 1. 复制行为：“值复制” vs “地址复制”

- **基本类型**：复制时会在栈中创建一个新的独立值，原变量和新变量互不影响。
  示例：

  js

  ```js
  let a = 10;
  let b = a; // 复制栈中的值 10，b 是新的独立值
  b = 20; 
  console.log(a); // 10（a 不受 b 影响）
  ```

- **引用类型**：复制时仅复制栈中的地址，原变量和新变量指向堆中同一个对象，修改其中一个会影响另一个。
  示例：

  js

  ```js
  let obj1 = { x: 1 };
  let obj2 = obj1; // 复制地址，obj1 和 obj2 指向同一个堆对象
  obj2.x = 2; 
  console.log(obj1.x); // 2（堆中对象被修改，两者同时受影响）
  ```

### 2. 比较行为：“值比较” vs “地址比较”

- **基本类型**：比较的是实际值是否相等。
  示例：

  js

  ```js
  console.log(10 === 10); // true（值相同）
  console.log('abc' === 'abc'); // true（值相同）
  ```

- **引用类型**：比较的是栈中存储的地址是否相同（即是否指向同一个堆对象），而非对象内容是否一致。
  示例：

  js

  ```js
  const obj1 = { x: 1 };
  const obj2 = { x: 1 };
  console.log(obj1 === obj2); // false（地址不同，是两个独立对象）
  ```

### 3. 参数传递：“值传递” vs “引用传递的表象”

JavaScript 中参数传递只有**值传递**，但引用类型的 “值传递” 传递的是地址，导致类似 “引用传递” 的效果：

- **基本类型作为参数**：函数接收的是值的副本，修改参数不影响外部变量。

  js

  ```js
  function changeNum(n) {
    n = 20;
  }
  let num = 10;
  changeNum(num);
  console.log(num); // 10（外部变量不受影响）
  ```

- **引用类型作为参数**：函数接收的是地址的副本，通过该地址修改堆中对象，会影响外部变量（因为指向同一个对象）。

  js

  ```js
  function changeObj(obj) {
    obj.x = 2; // 通过地址修改堆中对象
  }
  const obj = { x: 1 };
  changeObj(obj);
  console.log(obj.x); // 2（外部对象被修改）
  ```

## 四、特殊注意点与拓展

### 1. `null` 的特殊性

`null` 是基本类型，但 `typeof null` 会返回 `'object'`，这是 JavaScript 引擎的历史 Bug（早期实现中，`null` 被当作空指针，而指针在底层被识别为对象类型）。判断 `null` 需用 `=== null`。

### 2. 包装对象（Wrapper Objects）

基本类型（除 `null` 和 `undefined`）有对应的包装对象（`String`、`Number`、`Boolean`），用于临时提供方法（如 `'abc'.slice(1)`）：



- 当基本类型调用方法时，JavaScript 会临时创建包装对象（引用类型），执行方法后立即销毁。
  示例：`'abc'.length` 执行时，引擎会创建 `new String('abc')`，获取 `length` 后销毁该对象。

### 3. `Symbol` 和 `BigInt` 的唯一性

- `Symbol` 确保属性键的唯一性：`Symbol('id') !== Symbol('id')`，解决对象属性名冲突问题（如第三方库的属性命名）。
- `BigInt` 解决 Number 精度限制：Number 最大安全整数是 `2^53 - 1`（`9007199254740991`），超过则精度丢失，而 `BigInt` 可表示任意大整数。

### 4. 对性能和内存的影响

- 基本类型因存储在栈中，访问速度快，适合频繁操作的简单数据。
- 引用类型因存储在堆中，创建和销毁成本较高，频繁创建大对象可能导致垃圾回收压力（需注意内存泄漏，如未清理的定时器、事件监听引用）。

## 总结

JavaScript 数据类型的核心区别在于**存储位置和方式**：基本类型在栈中存储值，引用类型在堆中存储值、栈中存储地址。这种设计既保证了基本类型的高效访问，又满足了引用类型动态分配内存的需求。理解这些差异，能帮助我们避免开发中的常见陷阱（如引用类型复制后的意外修改），并在性能优化（如减少大对象复制）、深浅拷贝实现等场景中做出合理决策。
