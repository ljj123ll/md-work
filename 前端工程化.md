要实现 **ESLint+Stylelint+Husky 代码规范工具链** 和 **Vite 分块打包（分离依赖与业务代码）**，需分两大模块逐步配置。以下是基于现代前端工程化（适配 Vue/React + TypeScript 常见场景）的详细实现步骤，包含具体配置代码和原理说明。

# 集成 ESLint+Stylelint+Husky 工具链

该工具链的核心目标是：**在代码提交前强制检查代码语法、风格一致性**，避免不规范代码进入仓库，从而提升代码评审通过率、减少团队协作冲突。

## 前置条件

已初始化 Vite 项目（如 `npm create vite@latest my-project -- --template vue-ts` 或 `react-ts`），且已安装 `npm/yarn/pnpm` 包管理工具。

## 集成 ESLint（检查 JS/TS 代码）

ESLint 是 JavaScript/TypeScript 代码的静态检查工具，可检测语法错误、强制代码风格（如缩进、变量命名、禁止未使用变量等）。

### 安装依赖

根据技术栈安装对应插件（以 **Vue3+TypeScript** 为例，React 场景见备注）：

bash

```bash
# 核心依赖
npm install eslint --save-dev
# Vue 适配插件（React 场景替换为 eslint-plugin-react eslint-plugin-react-hooks）
npm install eslint-plugin-vue @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev
# 通用规则集（可选，简化配置）
npm install eslint-config-airbnb-base eslint-config-airbnb-typescript --save-dev
```

- React 场景依赖替换：

  bash

  ```bash
  npm install eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y --save-dev
  ```

### 配置 ESLint（核心文件：`.eslintrc.js`）

在项目根目录创建 `.eslintrc.js`，或者`.eslintrc.cjs`定义检查规则和适配逻辑：

javascript

运行

```javascript
module.exports = {
  // 环境：指定代码运行的环境（浏览器、Node、ES6 等）
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  // 解析器：处理 TypeScript 代码
  parser: 'vue-eslint-parser', // Vue 场景用；React 场景替换为 '@typescript-eslint/parser'
  // 解析器选项：指定 ES 版本和 TypeScript 配置
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    parser: '@typescript-eslint/parser', // Vue 场景需嵌套配置 TS 解析器
    tsconfigRootDir: __dirname,
    project: ['./tsconfig.json'] // 关联项目的 TS 配置，确保类型检查
  },
  // 插件：启用安装的 ESLint 插件
  plugins: [
    'vue', // Vue 场景；React 场景替换为 'react', 'react-hooks'
    '@typescript-eslint'
  ],
  // 规则集：继承已有的规则（如 airbnb 规范），再自定义规则
  extends: [
    'eslint:recommended',
    'plugin:vue/vue3-recommended', // Vue3 推荐规则；React 场景替换为 'plugin:react/recommended'
    'plugin:@typescript-eslint/recommended',
    'airbnb-base', // 通用 JS 规范
    'airbnb-typescript/base' // 通用 TS 规范
  ],
  // 自定义规则：覆盖继承的规则（0=关闭，1=警告，2=错误）
  rules: {
    // 禁止未使用的变量（开发环境可关闭，避免临时变量报错）
    '@typescript-eslint/no-unused-vars': process.env.NODE_ENV === 'production' ? 2 : 1,
    // 允许使用 console（生产环境可关闭）
    'no-console': process.env.NODE_ENV === 'production' ? 2 : 0,
    // Vue 模板中允许未定义的变量（如全局组件）
    'vue/undef': 0,
    // 缩进 2 个空格
    'indent': [2, 2],
    // 字符串使用单引号
    'quotes': [2, 'single']
  },
  // 忽略检查的文件/目录
  ignorePatterns: ['node_modules/', 'dist/', '*.config.js']
};
```

### 添加 ESLint 脚本（package.json）

在 `package.json` 的 `scripts` 中添加命令，方便手动运行检查 / 修复：

json

```json
{
  "scripts": {
    "lint:js": "eslint . --ext .js,.jsx,.ts,.tsx,.vue", // 检查所有目标文件
    "lint:js:fix": "eslint . --ext .js,.jsx,.ts,.tsx,.vue --fix" // 自动修复可修复的问题
  }
}
```

## 集成 Stylelint（检查 CSS/SCSS 样式）

Stylelint 是 CSS/SCSS/Less 等样式文件的静态检查工具，可强制样式规范（如禁止！important、统一单位、规范选择器命名等）。

### 安装依赖

bash

```bash
# 核心依赖
npm install stylelint stylelint-config-standard --save-dev
# 处理 SCSS（若用 Less 替换为 stylelint-less）
npm install stylelint-scss postcss-scss --save-dev
# 适配 Vue 单文件组件（.vue 中的 <style> 标签）
npm install stylelint-config-recommended-vue --save-dev
# 自动排序 CSS 属性（可选，如按布局、盒模型、外观排序）
npm install stylelint-order --save-dev
```

### 配置 Stylelint（核心文件：`.stylelintrc.js`）

在项目根目录创建 `.stylelintrc.js`：

javascript

运行

```javascript
module.exports = {
  // 检查的文件类型
  files: ['**/*.{css,scss,vue}'],
  // 继承的规则集
  extends: [
    'stylelint-config-standard', // 通用 CSS 规范
    'stylelint-config-standard-scss', // SCSS 规范
    'stylelint-config-recommended-vue/scss', // Vue 单文件组件规范
    'stylelint-order' // 启用属性排序
  ],
  // 自定义规则
  rules: {
    // 禁止使用 !important
    'declaration-no-important': 2,
    // 统一单位（如禁止 px，推荐 rem/vw，根据项目需求调整）
    'unit-allowed-list': ['rem', 'vw', 'vh', '%'],
    // CSS 属性排序规则（按布局 → 盒模型 → 外观 → 其他）
    'order/properties-order': [
      'position',
      'top',
      'right',
      'bottom',
      'left',
      'display',
      'width',
      'height',
      'margin',
      'padding',
      'border',
      'background',
      'color',
      'font-size',
      'line-height'
    ],
    // 允许空规则（如占位符样式）
    'no-empty-source': 0
  },
  // 忽略检查的文件
  ignoreFiles: ['node_modules/**/*', 'dist/**/*']
};
```

### 添加 Stylelint 脚本（package.json）

json

```json
{
  "scripts": {
    "lint:css": "stylelint **/*.{css,scss,vue}", // 检查样式文件
    "lint:css:fix": "stylelint **/*.{css,scss,vue} --fix", // 自动修复样式
    "lint": "npm run lint:js && npm run lint:css", // 同时检查 JS 和 CSS
    "lint:fix": "npm run lint:js:fix && npm run lint:css:fix" // 同时修复
  }
}
```

## 集成 Husky + lint-staged（提交前强制检查）

Husky 是 Git 钩子工具，可在代码提交（`git commit`）、推送（`git push`）前执行自定义脚本；`lint-staged` 仅检查 **暂存区文件**（避免检查整个项目，提升效率），二者结合可确保 “不规范代码无法提交”。

### 安装依赖

bash

```bash
# 安装 Husky 和 lint-staged
npm install husky lint-staged --save-dev
```

### 初始化 Husky

bash

```bash
# 启用 Git 钩子（生成 .husky 目录）
npx husky install
# 配置 npm 安装后自动启用 Husky（避免团队成员手动执行）
npm set-script prepare "husky install"
npm run prepare
```

### 添加 Git 钩子（pre-commit）

创建 `pre-commit` 钩子，在提交前执行 `lint-staged`：

bash

```bash
npx husky add .husky/pre-commit "npx lint-staged"
```

### 配置 lint-staged（package.json）

在 `package.json` 中添加 `lint-staged` 字段，定义 “不同类型文件的检查 / 修复规则”：

json

```json
{
  "lint-staged": {
    // JS/TS/Vue 文件：先自动修复，再检查（无法修复的报错阻止提交）
    "*.{js,jsx,ts,tsx,vue}": ["eslint --fix", "eslint"],
    // CSS/SCSS/Vue 文件：先自动修复，再检查
    "*.{css,scss,vue}": ["stylelint --fix", "stylelint"],
    // 可选：格式化代码（需安装 prettier）
    "*.{json,md}": ["prettier --write"]
  }
}
```

### 效果验证

当执行 `git add .` 和 `git commit -m "test"` 时，若暂存区有不规范代码：

1. 首先自动尝试修复（如缩进、引号格式）；
2. 若修复后仍有错误（如未使用的变量），则提交失败，需手动修改后重新提交。



# Vite 配置分块打包（分离依赖与业务代码）

Vite 基于 Rollup 构建，通过 `build.rollupOptions` 配置 **代码分割（Code Splitting）**，将第三方依赖（如 Vue、React、Axios）与业务代码（如 `src` 目录下的组件、页面）分开打包，核心好处是：

- 依赖变动少，可被浏览器缓存（下次加载无需重新下载）；
- 业务代码体积小，首屏加载更快。

## 核心原理

- **依赖代码**：第三方库（如 `node_modules` 中的包），打包为独立的 `vendor-xxx.js`；
- **业务代码**：项目 `src` 目录下的代码，按页面 / 模块打包为 `app-xxx.js` 或 `page-xxx.js`；
- 通过 `manualChunks` 手动指定分块规则，Rollup 会自动处理模块依赖关系。

## 详细配置步骤（vite.config.js）

1. 打开项目根目录的 `vite.config.js`（或 `vite.config.ts`）；
2. 在 `build` 选项中配置 `rollupOptions`，具体如下：

javascript

运行

```javascript
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue'; // Vue 插件（React 用 @vitejs/plugin-react）
import path from 'path';

export default defineConfig({
  plugins: [vue()], // 适配框架的插件
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src') // 配置 @ 指向 src 目录（可选）
    }
  },
  // 构建配置（核心）
  build: {
    // 1. 输出目录（默认 dist，可自定义）
    outDir: 'dist',
    // 2. 静态资源目录（默认 assets，可自定义）
    assetsDir: 'assets',
    // 3. 关闭 sourcemap（生产环境不需要，减小文件体积）
    sourcemap: false,
    // 4. Rollup 打包配置（分块核心）
    rollupOptions: {
      // 入口文件（默认 src/main.js，根据项目调整）
      input: {
        main: path.resolve(__dirname, 'index.html')
      },
      // 输出文件命名规则（可选，规范文件名）
      output: {
        // 静态资源文件名：[name]（原文件名）-[hash]（哈希值，避免缓存问题）
        assetFileNames: 'assets/[name]-[hash].[ext]',
        //  chunk 文件名：[name]（分块名）-[hash]
        chunkFileNames: 'js/[name]-[hash].js',
        // 入口文件命名
        entryFileNames: 'js/[name]-[hash].js',
        // 5. 手动分块规则（分离依赖与业务代码）
        manualChunks: (id) => {
          // id 是模块的路径（如 node_modules/vue/dist/vue.runtime.esm-bundler.js）
          if (id.includes('node_modules')) {
            // 情况1：将第三方依赖按库名分组（如 vue 相关打包为 vendor-vue）
            if (id.includes('vue') || id.includes('@vue')) {
              return 'vendor-vue'; // 输出为 js/vendor-vue-[hash].js
            } else if (id.includes('axios') || id.includes('lodash')) {
              return 'vendor-utils'; // 工具库打包为 js/vendor-utils-[hash].js
            } else {
              // 情况2：其他依赖统一打包为 vendor-common
              return 'vendor-common';
            }
          } else if (id.includes('src/pages')) {
            // 情况3：业务代码按页面分块（如 src/pages/Home 打包为 page-home）
            const pageName = id.match(/src\/pages\/(\w+)/)[1];
            return `page-${pageName.toLowerCase()}`; // 输出为 js/page-home-[hash].js
          }
          // 情况4：默认不指定，Rollup 自动按业务模块分块（如 src/components 打包为 app-xxx）
        }
      },
      // 6. 大文件警告阈值（默认 500kb，超过会报警，可根据需求调整）
      chunkSizeWarningLimit: 1000
    }
  }
});
```

## 配置说明

| 配置项                  | 作用                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `output.manualChunks`   | 核心分块规则：通过模块路径（`id`）判断该模块属于 “依赖” 还是 “业务”，并指定分块名 |
| `assetFileNames`        | 静态资源（图片、字体等）的输出路径和命名，哈希值确保缓存更新 |
| `chunkFileNames`        | 非入口 chunk（如分块后的依赖、业务模块）的命名规则           |
| `chunkSizeWarningLimit` | 大文件警告阈值，避免单个 chunk 过大导致加载缓慢（可配合 `terser` 压缩） |

## 验证分块效果

1. 执行构建命令：`npm run build`；

2. 打开

   ```
   dist/js
   ```

   

   目录，会看到以下分块文件（示例）：

   - `vendor-vue-xxx.js`：Vue 相关依赖；
   - `vendor-utils-xxx.js`：Axios、Lodash 等工具库；
   - `page-home-xxx.js`：首页业务代码；
   - `app-xxx.js`：其他业务公共模块；

3. 打开浏览器访问 `dist/index.html`，通过 **开发者工具 → 网络 → JS** 可看到：依赖和业务代码分开加载，且依赖文件会被缓存（刷新后状态为 `200 (from disk cache)`）。

# 三、最终效果与优化建议

## 代码规范工具链效果

- 提交代码时自动检查并修复不规范内容，强制代码风格统一；
- 代码评审时无需关注格式问题，专注业务逻辑，通过率提升（如用户提到的 50%）；
- 减少因格式冲突导致的 Git 合并冲突（如用户提到的 35% 下降）。

## Vite 分块打包效果

- 依赖代码与业务代码分离，首屏仅加载核心依赖和当前页面业务代码，加载时间降低（如用户提到的从 2.8s 降至 1.9s）；
- 依赖文件缓存生效，二次访问速度更快。

## 额外优化建议

- **压缩代码**：Vite 默认使用 `esbuild` 压缩，生产环境已开启，可通过 `build.minify: 'terser'` 进一步压缩（需安装 `terser`）；
- **CDN 加速**：将 `vendor-xxx.js` 等依赖通过 CDN 引入（如 Vue、React 的官方 CDN），减少服务器带宽压力；
- **按需加载**：配合框架的路由懒加载（如 Vue Router 的 `() => import('@/pages/Home')`），进一步拆分业务代码，首屏仅加载路由入口。



# 配置prettier

集成 Prettier 可以进一步统一代码格式（如换行、引号、缩进等），与 ESLint/Stylelint 形成互补（ESLint 侧重语法与逻辑，Prettier 侧重格式）。以下是详细的配置步骤，确保 Prettier 与已有工具链兼容且自动生效。

## 安装 Prettier 及相关依赖

Prettier 本身是独立工具，需安装核心包及与 ESLint/Stylelint 的兼容插件（避免规则冲突）。

bash

```bash
# 核心依赖：Prettier 格式化工具
npm install prettier --save-dev

# ESLint 与 Prettier 兼容：关闭 ESLint 中与 Prettier 冲突的格式规则
npm install eslint-config-prettier --save-dev

# （可选）让 ESLint 直接使用 Prettier 规则作为检查项（格式问题会报 ESLint 错误）
npm install eslint-plugin-prettier --save-dev

# Stylelint 与 Prettier 兼容：关闭 Stylelint 中与 Prettier 冲突的格式规则
npm install stylelint-config-prettier --save-dev
```

## 配置 Prettier 格式化规则

创建 Prettier 配置文件，定义项目统一的格式规则（支持 `.prettierrc.js`、`.prettierrc.json` 等格式，推荐 JS 格式便于注释）。

在项目根目录创建 `.prettierrc.js`：

javascript

运行

```javascript
module.exports = {
  // 每行代码的最大长度（超过会自动换行）
  printWidth: 100,
  // 缩进空格数（2 空格或 4 空格，根据团队习惯）
  tabWidth: 2,
  // 使用空格代替制表符（tab）
  useTabs: false,
  // 语句末尾是否加分号（推荐不加分号，更简洁）
  semi: false,
  // 字符串使用单引号（与 ESLint 规则保持一致）
  singleQuote: true,
  // 对象/数组的最后一个元素后是否加逗号（如 { a: 1, b: 2, }）
  trailingComma: 'all', // 可选值：'none' | 'es5' | 'all'
  // 对象字面量的括号间是否加空格（如 {a: 1} vs { a: 1 }）
  bracketSpacing: true,
  // 箭头函数参数是否加括号（如 (x) => x vs x => x）
  arrowParens: 'always', // 推荐 'always'，避免单参数时的格式歧义
  // HTML/Vue/JSX 中 > 符号是否换行（默认不换行）
  bracketSameLine: false,
  // 换行符格式（自动根据系统判断，也可强制 'lf' | 'crlf' | 'cr'）
  endOfLine: 'auto',
  // 格式化时是否忽略某些文件（需配合 .prettierignore）
  ignorePath: '.prettierignore'
};
```

## 配置忽略文件（.prettierignore）

创建 `.prettierignore` 文件，指定 Prettier 不需要格式化的文件 / 目录（与 `.gitignore` 类似）：

plaintext

```plaintext
# 依赖目录
node_modules/
# 构建产物
dist/
# 配置文件（如 vite.config.js 可能有特殊格式，无需格式化）
*.config.js
# 其他不需要格式化的文件
*.md
*.json
```

## 与 ESLint 集成（关键：避免规则冲突）

修改 `.eslintrc.js`，通过 `eslint-config-prettier` 关闭 ESLint 中与 Prettier 冲突的格式规则（如缩进、引号等），确保二者兼容。

更新后的 `.eslintrc.js` 核心配置：

javascript

运行

```javascript
module.exports = {
  // ... 其他配置不变
  extends: [
    // ... 原有规则
    'eslint:recommended',
    'plugin:vue/vue3-recommended',
    'plugin:@typescript-eslint/recommended',
    'airbnb-base',
    'airbnb-typescript/base',
    
    // 关键：放在最后，覆盖前面可能冲突的格式规则
    'prettier', // 关闭 ESLint 与 Prettier 冲突的规则
    'plugin:prettier/recommended' // （可选）将 Prettier 格式问题作为 ESLint 错误抛出
  ],
  // ... 其他配置不变
};
```

- **作用说明**：
  `prettier` 配置会禁用 ESLint 中所有与格式相关的规则（如 `indent`、`quotes`），避免 ESLint 和 Prettier 对同一格式问题产生冲突；
  若启用 `plugin:prettier/recommended`，Prettier 检测到的格式问题会以 ESLint 错误的形式出现，统一在 `npm run lint` 中报错。

## 与 Stylelint 集成（避免样式格式冲突）

修改 `.stylelintrc.js`，通过 `stylelint-config-prettier` 关闭 Stylelint 中与 Prettier 冲突的样式格式规则（如空格、换行）。

更新后的 `.stylelintrc.js` 核心配置：

javascript

运行

```javascript
module.exports = {
  // ... 其他配置不变
  extends: [
    'stylelint-config-standard',
    'stylelint-config-standard-scss',
    'stylelint-config-recommended-vue/scss',
    'stylelint-order',
    
    // 关键：放在最后，关闭冲突规则
    'stylelint-config-prettier'
  ],
  // ... 其他配置不变
};
```

## 集成到 Husky + lint-staged（提交前自动格式化）

修改 `package.json` 中的 `lint-staged` 配置，在提交前通过 Prettier 自动格式化暂存区文件，确保格式符合规范。

更新后的 `lint-staged` 配置：

json

```json
{
  "lint-staged": {
    // JS/TS/Vue 文件：先 Prettier 格式化，再 ESLint 检查
    "*.{js,jsx,ts,tsx,vue}": ["prettier --write", "eslint --fix", "eslint"],
    // CSS/SCSS/Vue 文件：先 Prettier 格式化，再 Stylelint 检查
    "*.{css,scss,vue}": ["prettier --write", "stylelint --fix", "stylelint"],
    // 纯文本/JSON/Markdown 等文件：仅 Prettier 格式化
    "*.{json,md,yml}": ["prettier --write"]
  }
}
```

- **执行顺序**：
  `prettier --write` 先自动格式化文件 → `eslint/stylelint --fix` 修复语法 / 样式问题 → 最后执行检查，确保无残留问题。

## 添加 npm 脚本（手动触发格式化）

在 `package.json` 中添加 Prettier 相关脚本，方便手动格式化整个项目或指定文件：

json

```json
{
  "scripts": {
    // 格式化所有文件（排除 .prettierignore 中的内容）
    "format": "prettier --write .",
    // 检查哪些文件需要格式化（不实际修改）
    "format:check": "prettier --check ."
  }
}
```

- 使用方式：
  - 手动格式化所有文件：`npm run format`
  - 检查未格式化的文件：`npm run format:check`（CI/CD 中可用于强制检查）

## IDE 配置（提升开发体验）

为避免开发时 IDE 自带格式化工具与 Prettier 冲突，建议在 VSCode 中配置默认使用 Prettier：

1. 安装 VSCode 插件：`Prettier - Code formatter`；
2. 打开 VSCode 配置（`settings.json`），添加：

json

```json
{
  // 默认格式化工具选择 Prettier
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  // 保存时自动格式化
  "editor.formatOnSave": true,
  // 保存时自动运行 ESLint 修复（与 Prettier 配合）
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true,
    "source.fixAll.stylelint": true
  },
  // 忽略格式化的文件类型（可选）
  "prettier.ignorePath": ".prettierignore"
}
```

## 验证配置

1. **手动验证**：
   修改一个文件（如故意使用双引号、不换行），执行 `npm run format`，观察是否自动修复为 Prettier 规则；
   执行 `npm run lint`，确认无格式相关的报错。
2. **提交验证**：
   执行 `git add .` 和 `git commit -m "test prettier"`，若存在未格式化的文件，Husky 会自动触发 Prettier 格式化，若格式化后仍有问题则提交失败，需手动修改。

## 总结

通过以上步骤，Prettier 会与 ESLint/Stylelint/Husky 形成完整的代码质量保障链：

- **Prettier**：负责统一代码格式（换行、引号等）；
- **ESLint/Stylelint**：负责语法、逻辑、样式规范检查；
- **Husky + lint-staged**：确保提交前自动修复 / 检查，阻止不规范代码入库。

最终实现 “开发时自动格式化，提交时强制检查”，进一步减少团队协作中的格式冲突，提升代码一致性。





# 我已经成功为项目配置了 ESLint+Stylelint+Husky 工具链，具体完成了以下工作：



## ESLint 配置 ：

- 创建了 .eslintrc.cjs 配置文件，设置了适合 Vue 3 项目的 ESLint 规则
- 创建了 .eslintignore 文件，忽略不需要检查的文件和目录
- 测试了 ESLint 能够正常运行（虽然发现了一些代码中的实际错误）



## Stylelint 配置 ：

- 安装了 Stylelint 及其相关依赖包
- 创建了 .stylelintrc.cjs 配置文件，适配了项目的 SCSS 语法
- 创建了 .stylelintignore 文件，忽略不需要检查的文件和目录
- 测试了 Stylelint 能够正常运行

## Husky 配置 ：

- 运行 pnpm run prepare 初始化了 husky
- 创建了 .husky/pre-commit hook 文件

## lint-staged 配置 ：

- 更新了 package.json 中的 lint-staged 配置，同时支持 ESLint 和 Stylelint 检查
- 为 JavaScript/Vue 文件配置了 ESLint 检查
- 为 SCSS/CSS 文件配置了 Stylelint 检查

## 添加了便捷脚本 ：

- 添加了 lint:style 脚本，用于单独运行样式检查
- 添加了 lint:all 脚本，用于同时运行 ESLint 和 Stylelint 检查
现在，当你执行 git commit 命令时，husky 会自动运行 lint-staged，对暂存的文件进行代码质量检查，确保不符合规范的代码不会被提交到仓库中。这有助于保持代码质量的一致性和提高团队协作效率。

## Prettier配置已成功完成！我已为您的Vue3项目添加了完整的Prettier格式化工具配置，包括：


创建了 `.prettierrc.cjs` 配置文件，设置了适合Vue项目的格式化规则，如：

- 使用2个空格缩进
- 使用单引号
- 句尾不添加分号
- 自动换行长度为100个字符
- 对Vue文件中的script和style部分应用缩进


创建了 `.prettierignore` 文件，定义了不需要格式化的文件和目录，包括node_modules、构建输出、日志文件等


在 `package.json` 中添加了 format 脚本命令，您可以通过 pnpm run format 手动格式化整个项目


更新了lint-staged配置，使其在git提交前自动运行Prettier格式化：

- JavaScript、TypeScript和Vue文件：先ESLint修复，再Prettier格式化
- SCSS和CSS文件：先Stylelint修复，再Prettier格式化
- Markdown、JSON和HTML文件：直接Prettier格式化


已通过运行 pnpm run format 命令验证了Prettier配置正常工作，所有文件已成功格式化
现在您的项目已经集成了完整的代码质量工具链（ESLint + Stylelint + Prettier + Husky + lint-staged），可以确保代码风格的一致性和代码质量。每次git提交时，这些工具会自动检查并格式化您的代码！