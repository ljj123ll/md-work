# 功能：

## 前台功能：

### 首页：

顶部导航栏从左到右显示首页，关于我们，租凭中心，新闻资讯，客服中心。

搜索图标（鼠标移入时弹出搜索框），

用户图标（未登录时点击进入登录页面；登陆后点击进入个人页面），

购物车图标（鼠标移入时弹出一小栏购物车，未登录时也可以把物品加入购物车，登陆后把未登录中的购物车中的东西和账号已有的购物车中的东西合并，一小栏购物车下面有一个按钮名为“去购物车结算”，点击进入购物车详情页面）。

首页有三种样式的轮播图。点击图片时会根据图片的productId匹配产品的id，匹配到两者相等则跳转到对应的产品详情页面（如果没有匹配到则弹出信息‘未找到该商品’）

首页还有一个视频轮播组件和轮播图组件类似，只是图片换成了视频，且同样可以根据匹配id跳转到详情页面。

首页最下面是一个静态页脚组件。



### 关于我们：

最上面是一张图片显示关于我们。

中间及一下主要是用于介绍我们公司的静态页面。



### 租凭中心：

最上面是一张照片显示租聘中心。

下面是类似这样的：

<img src="./images/产品中心展示.png" alt="产品展示" style="zoom:75%;" />

可以根据产品类别【大疆无人机，大疆手持设备，微单相机，单反相机】和品牌【大疆，索尼，佳能，尼康，富士】分页（每页20个产品）显示对应的产品，点击对应的产品可以进入产品详情页面。

产品详情页面：

左边是图片展示，每个产品拥有五张图片（正方形），右边从上到下显示

产品名称（举例：尼康D850，大疆Osmo Action 5Pro），

产品特点简介(举例：全新 1/1.3 英寸传感器，旗舰影像 | 人物居中，锁定主角 | 双 OLED 高亮触摸屏 | 360° 地平线增稳，硬核防抖 | 大容量电池，4 小时超长续航 | 双 DJI 麦克直连，专业收音)，

产品品牌（举例：大疆，索尼，佳能，尼康，富士），

产品Id（举例：Nikon-D850，DJI-OsmoAction4），

租凭规格【3天每天50元，5天每天40元，7天每天30元，15天每天20元】，

数量选择（不能为0和负数），

加入购物车按钮，点击后会加入购物车。

下方还有商品的品牌详情介绍和产品详情介绍。

一个发表评论栏【打星（1-5），评论，点击发布按钮】

最下面是分页显示评论，评论包括【文字评论（50字上限）、评分(1-5 星)、评论时间、用户账号】，评论默认按时间排序显示，第一页显示最新的评论。



### 新闻资讯：

最上面是一张照片显示新闻资讯。

下面是一块一块的新闻【块里面包含：图片，新闻标题，发布时间，修改时间，发布人】，分页显示，每页只显示9块新闻，按照发布时间排序，第一页显示最新的新闻。

点击会进入新闻详情页面【从上到下：标题，发布时间，修改时间，发布人，正文（采用md文档转换成的），返回按钮（返回到显示一块一块新闻资讯的分页页面）】



### 客服中心：

最上面是一张照片显示客服中心。

中间是一个提出问题的模块，用户可以输入问题，选择问题的类型【租金问题，押金问题，下单问题，保险问题，售后问题，其他问题】，后台页面会接收到该问题，当管理员在后台填写这个问题的回答之后，这个问题就会显示到相关的问题模块里面。

下面是6块常见问题【租金问题，押金问题，下单问题，保险问题，售后问题，其他问题】，点击相关问题进入相关问题的详情页面。

进入后会有一条一条的块，里面包含问题和回答，分页显示，每页显示20条问题。【里面暗含了创建时间和修改时间，按照创建时间排列问题，最新的问题显示在第一页】

<img src="./images/问题模块.png" alt="问题模块" style="zoom:75%;" />





### 登陆注册：

登录页面如下：

<img src="./images/登录页面.png" alt="登录页面" style="zoom:75%;" />

注册页面如下：

<img src="./images/注册页面.png" alt="注册页面" style="zoom:75%;" />





### 个人中心：

个人信息及修改：

<img src="./images/修改基本信息.png" alt="修改个人信息" style="zoom:75%;" />



修改密码：

<img src="./images/修改密码.png" alt="修改密码" style="zoom:75%;" />

订单列表：

分为【全部订单，待付款，待收货，待归还，已完成，已取消】

从左到右分别为：订单编号，

订购的产品名称（可能有好几个，换行排列），

每个产品后面显示数量，

订单总额，

订单状态【待付款，待收货，待归还，已完成，已取消】，

创建时间，

查看详情。



点击查看详情进入该订单的详情页面，从上到下：

订单状态，

收货地址【姓名，电话，地址】，

是否收货，

订购的产品信息【产品名称，产品Id，租凭规格，租凭数量，该商品的租凭价格】，

总价格，

下单时间，

订单编号。



最下面有

继续付款（当订单状态是【待付款】时才能点击，点击后订单状态变成【待收货】）

取消按钮（当订单状态是【待付款】时才能点击，点击后订单状态变成【已取消】）

确认收货（当订单是【待收货】状态时才能点击，点击后订单状态变成【待归还】）

归还按钮（当订单状态是【待归还】的时候点击，点击后订单状态变成【已完成】）



### 购物车详情：







## 后台功能：



















































# 数据库设计(MongoDB)

## 用户表：









## 轮播图表







































# API接口



































# 前端

### 目录解析











































# 后端

### 目录解析

















# 遇见的问题

##  “**唯一标识存储**”“**切断跨源通道**”“**后端校验隔离**”

我先运行5173端口这个项目登录产生一个token存储在5173，后来我又运行另一个项目在端口5174，为什么这个项目会自动获取5173端口的token然后自动变成登录状态，而且数据也全部传过来，我清除5174的本地缓存之后，重新启动之后就没有了，两个网站的cookie都为空。我清除5174的本地缓存之后重新启动项目之后就没有了，需要自己登录。解释上面事情发生的原理，以及告诉我怎么避免我从github git clone这个项目启动后就会因为5173中存储的token而产生自动登录

要解决两个本地项目（5173/5174 端口）共享登录态的问题，需先明确**浏览器存储隔离规则**与**项目逻辑漏洞**的核心原理，再针对性切断跨源数据传递通道。

### 一、现象背后的核心原理

你遇到的 “5174 自动读取 5173 的 token”，本质是**前端存储跨源传递 + 项目逻辑未隔离**导致的，而非浏览器原生存储 “打破同源策略”（浏览器严格按「协议 + 域名 + 端口」隔离 localStorage/sessionStorage）。具体拆解为两个关键环节：

1. 浏览器存储的 “隔离性” 与 “可传递性”

浏览器的`localStorage`/`sessionStorage`遵循**同源策略**：仅允许当前「协议 + 域名 + 端口」的页面读写自身存储（例：`localhost:5173`的存储无法被`localhost:5174`直接读取）。但以下场景会导致跨源传递 token：

- **存储 key 冲突 + 跨源数据注入**：两个项目存储 token 的 key 相同（如都用`token`作为 key），且 5173 通过「跨源通信」将 token 传递给 5174（如 5173 的页面用`postMessage`发送 token，5174 的页面监听`postMessage`并将 token 存入自身`localStorage`）。
- **浏览器插件 / 缓存干扰**：部分跨域调试插件、缓存同步插件可能绕过同源策略，将 5173 的存储数据同步到 5174；或浏览器缓存了 5173 的 token 请求，5174 启动时复用了缓存的 token 响应。

2. 项目逻辑的 “未隔离” 漏洞

- **token 读取未校验来源**：5174 的代码仅判断 “是否存在`token` key”，未校验 token 是否属于自身项目（如未附加项目标识），直接使用了 5173 注入的 token。
- **后端会话未隔离**：若两个项目对接同一后端，后端未按项目 / 端口隔离登录会话（如仅用 IP 识别用户），5173 登录后，5174 请求接口时后端误将其关联到 5173 的会话，返回登录态。

### 二、避免自动登录的解决方案

核心目标：**切断 5174 获取 5173 token 的通道** + **确保 5174 仅使用自身源的有效 token**，具体分 5 步落地：

1. **让 token 存储 “带唯一标识”，避免冲突**

两个项目用相同的`key`（如`token`）存储，是跨源复用的直接诱因。需给存储 key 加 “项目专属标识”：

- 修改存储 key

  ：将存储 token 的 key 从通用名改为 “项目 + 端口” 唯一值，例：

  javascript

  ```javascript
  // 5174项目的存储逻辑（替换原代码）
  const TOKEN_KEY = `token_${import.meta.env.VITE_PORT}`; // 用环境变量区分端口
  // 存储token
  localStorage.setItem(TOKEN_KEY, token);
  // 读取token（仅读自身key）
  const token = localStorage.getItem(TOKEN_KEY);
  ```

- **清除历史冲突 key**：启动 5174 前，手动删除浏览器中`localhost:5174`下的旧`token`（浏览器 F12→Application→Storage→Local Storage→找到`localhost:5174`→删除`token`条目）。

2. **切断跨源数据传递通道**

若项目中存在`postMessage`（跨页面通信）逻辑，需限制其 “仅接收可信源”，避免 5173 注入 token：

- 检查并修改 postMessage 监听

  ：删除无限制的

  ```
  message
  ```

  事件监听，或添加源校验：

  javascript

  ```javascript
  // 错误写法（无限制接收）
  window.addEventListener('message', (e) => {
    if (e.data.type === 'TOKEN') localStorage.setItem('token', e.data.value); // 风险！
  });
  
  // 正确写法（仅接收自身源或可信域名）
  window.addEventListener('message', (e) => {
    // 仅允许当前项目源（5174）或后端域名发送消息
    const trustedOrigins = ['http://localhost:5174', 'https://your-backend.com'];
    if (!trustedOrigins.includes(e.origin)) return; // 非可信源直接忽略
    if (e.data.type === 'TOKEN') localStorage.setItem(TOKEN_KEY, e.data.value);
  });
  ```

- **禁用跨源干扰插件**：关闭浏览器中 “跨域调试”“缓存同步” 类插件（如 CORS Unblock、Cache Killer），这类插件可能绕过同源策略同步存储数据。

3. **让后端 “隔离会话”，拒绝其他项目的 token**

若两个项目对接同一后端，需让后端按 “项目标识” 区分登录会话，避免复用 5173 的 token：

- 请求时附加项目标识

  ：5174 请求接口时，在 Header 中添加专属标识（如端口），例：

  javascript

  ```javascript
  // 5174项目的请求拦截器（Axios为例）
  axios.interceptors.request.use((config) => {
    config.headers['X-Project-Port'] = import.meta.env.VITE_PORT; // 传递5174端口
    config.headers['Authorization'] = `Bearer ${token}`;
    return config;
  });
  ```

- **后端校验项目标识**：后端接收到请求后，先校验`X-Project-Port`与 token 的关联性（如 token 中嵌入端口信息），若 token 属于 5173（端口不匹配），则返回 “token 无效”，强制 5174 重新登录。

4. **优化 Vite 开发环境隔离**

Vite 开发环境的默认配置可能存在 “源混淆”，需通过`vite.config.js`强化隔离：

javascript

```javascript
// vite.config.js
export default defineConfig({
  server: {
    port: 5174, // 固定端口
    headers: {
      'Cache-Control': 'no-store', // 禁用浏览器缓存，避免复用5173的token缓存
      'X-Frame-Options': 'DENY', // 禁止嵌入5173的iframe，切断iframe跨源通信
    },
    origin: 'http://localhost:5174', // 明确当前源，避免Vite返回模糊源导致混淆
  },
  define: {
    'import.meta.env.VITE_PORT': JSON.stringify(5174), // 注入端口环境变量（供存储key使用）
  },
});
```

5. 启动时 “校验 token 有效性”，而非直接使用

即使 5174 的存储中存在 token，也需先向后端验证是否属于自身项目，避免无效 token 自动登录：

javascript

```javascript
// 5174项目启动时的登录态校验逻辑
async function checkLoginState() {
  const token = localStorage.getItem(TOKEN_KEY);
  if (!token) return false; // 无token，跳转登录

  try {
    // 向后端发送“token有效性校验请求”
    const res = await axios.get('/api/check-token', {
      headers: { 'X-Project-Port': import.meta.env.VITE_PORT },
    });
    return res.data.valid; // 后端返回true则保持登录，false则清除token
  } catch (err) {
    localStorage.removeItem(TOKEN_KEY); // 校验失败，清除token
    window.location.href = '/login'; // 跳转登录页
    return false;
  }
}

// 项目初始化时执行校验
checkLoginState();
```

### 三、总结

问题根源是「存储 key 冲突 + 跨源数据传递 + 后端会话未隔离」，解决方案围绕 “**唯一标识存储**”“**切断跨源通道**”“**后端校验隔离**” 三个核心，确保 5174 仅使用自身生成的有效 token，彻底避免 “clone 项目后自动登录” 的情况。



### 解决方法：

结合你提供的 **5173（小兔鲜）** 和 **5174（租客行）** 项目完整代码，自动登录的核心原因是 **Pinia Store ID 冲突 + 持久化存储跨项目复用**，而非浏览器原生跨源读取。以下是具体原理拆解和可直接落地的解决方案：

#### 一、自动登录的根本原因（从代码中定位）

两个项目的 **Pinia 状态管理逻辑** 和 **持久化存储配置** 存在冲突，导致 5174 误读了 5173 存储的 Token，具体分 3 步：

1. **5173 项目：Pinia 自动持久化 Token 到 localStorage**

5173 的 `useUserStore` 配置了 **`persist: true`**（Pinia Persisted State 插件的核心配置）：

javascript

```javascript
// 5173 的 useUserStore（关键代码）
export const useUserStore = defineStore(
  'user', // Store ID 为 "user"
  () => { /* 状态逻辑 */ },
  {
    persist: true // 开启自动持久化：将 Store 数据存到 localStorage
  }
)
```

- **持久化规则**：Pinia Persisted State 插件会默认将 Store 数据存入 `localStorage`，存储的 **key 为 `pinia/${storeId}`**（即 `pinia/user`）。
- **存储内容**：5173 登录后，`userStore.userInfo` 包含 Token，插件会自动将 `userInfo`（含 Token）写入 `localStorage` 的 `pinia/user` 键中。

2. **5174 项目：误读 5173 的 Pinia 持久化存储**

5174 的 `useUserStore` 虽然没有显式配置 `persist: true`，但存在两个关键漏洞：

- **Store ID 冲突**：5174 的 Store ID 也为 `user`（与 5173 完全一致）：

  javascript

  ```javascript
  // 5174 的 useUserStore（关键代码）
  export const useUserStore = defineStore('user', { /* 状态逻辑 */ })
  ```

  若 5174 项目中 **安装了 Pinia Persisted State 插件**（即使未显式配置 `persist`），插件会默认读取 `localStorage` 中 `pinia/user` 键的数据（即 5173 存储的 Token），并注入到 5174 的 `userStore` 中。

- **手动读取存储未做隔离**：5174 的 `userStore` 手动从 `localStorage` 读取 `token` 和 `userInfo`：

  javascript

  ```javascript
  // 5174 的 userStore 初始化（关键代码）
  state: () => ({
    token: localStorage.getItem('token') || '', // 读取 "token" 键
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null') // 读取 "userInfo" 键
  })
  ```

  若 5173 有逻辑（如插件、误写代码）将 `pinia/user` 中的 Token 复制到 `token` 键，5174 会直接读取该 Token 并用于请求。

3. **后端未校验 Token 归属，直接通过认证**

两个项目若对接 **同一后端**，后端仅验证 Token 有效性（如签名是否正确），未校验 Token 属于哪个项目（5173/5174），导致 5174 携带 5173 的 Token 请求时，后端认为是合法登录态，返回用户数据。

#### 二、彻底解决：3 步切断跨项目 Token 复用

核心目标：**让两个项目的存储 key 完全不冲突** + **确保 Token 仅归属自身项目**，以下是可直接复制修改的代码方案：

**第一步：给 Pinia Store 加 “项目专属 ID”，避免冲突**

两个项目的 Store ID 均为 `user` 是冲突根源，需添加项目 / 端口标识：

javascript

```javascript
// 1. 5173 项目：修改 useUserStore 的 Store ID（加端口标识）
export const useUserStore = defineStore(
  'user_5173', // 专属 ID：项目名+端口
  () => {
    // 原有逻辑不变（userInfo、getUserInfo、clearUserInfo）
  },
  {
    persist: true,
    // 可选：显式指定持久化 key，避免插件默认规则变动
    persist: {
      key: 'pinia_user_5173', // 自定义存储 key，与 5174 完全不同
      paths: ['userInfo'] // 仅持久化 userInfo，减少冗余
    }
  }
)

// 2. 5174 项目：修改 useUserStore 的 Store ID（加端口标识）
export const useUserStore = defineStore(
  'user_5174', // 专属 ID：项目名+端口
  {
    state: () => ({
      // 手动存储的 key 也加专属标识
      token: localStorage.getItem('token_5174') || '',
      userInfo: JSON.parse(localStorage.getItem('userInfo_5174') || 'null')
    }),
    actions: {
      // 修改 saveLoginInfo：存储到专属 key
      saveLoginInfo(token: string, userInfo: UserInfo) {
        this.token = token;
        this.userInfo = userInfo;
        // 存储到加标识的 key
        localStorage.setItem('token_5174', token);
        localStorage.setItem('userInfo_5174', JSON.stringify(userInfo));
      },
      // 修改 logout：清除专属 key
      logout() {
        this.token = '';
        this.userInfo = null;
        localStorage.removeItem('token_5174');
        localStorage.removeItem('userInfo_5174');
      }
    }
  }
)
```

**第二步：5174 禁用不必要的 Pinia Persist 插件**

若 5174 不需要自动持久化（已手动处理 `localStorage`），需彻底移除 Pinia Persisted State 插件，避免误读：

1. 卸载插件

   （终端执行）：

   bash

   ```bash
   npm uninstall pinia-plugin-persistedstate
   # 或 yarn remove pinia-plugin-persistedstate
   ```

2. 删除插件注册代码

   （通常在

   ```
   main.js
   ```

   或

   ```
   store/index.js
   ```

   ）：

   javascript

   ```javascript
   // 删掉类似以下的代码（5174 项目）
   import { createPinia } from 'pinia';
   import piniaPluginPersistedstate from 'pinia-plugin-persistedstate';
   const pinia = createPinia();
   pinia.use(piniaPluginPersistedstate); // 移除这行
   ```

**第三步：后端加 Token 归属校验（关键补充）**

仅前端处理仍有风险（如 Token 被手动复制），需后端配合校验 Token 是否属于当前项目：

1. 前端请求时附加项目标识

   ：在请求头添加项目 / 端口信息，5173 和 5174 分别传不同值：

   javascript

   ```javascript
   // 5173 的 request 拦截器（修改）
   request.interceptors.request.use((config) => {
     const userStore = useUserStore();
     if (userStore.userInfo.token) {
       config.headers.Authorization = `Bearer ${userStore.userInfo.token}`;
       config.headers['X-Project-Id'] = 'project_5173'; // 项目专属标识
     }
     return config;
   });
   
   // 5174 的 request 拦截器（修改）
   request.interceptors.request.use((config) => {
     const userStore = useUserStore();
     if (userStore.token) {
       config.headers.Authorization = `Bearer ${userStore.token}`;
       config.headers['X-Project-Id'] = 'project_5174'; // 项目专属标识
     }
     return config;
   });
   ```

2. **后端校验**：解析 Token 时，同时检查 `X-Project-Id` 是否与 Token 生成时的项目一致（如 Token payload 中嵌入项目 ID），不一致则返回 401 错误。

三、验证与清理：确保旧数据不干扰

修改后需清除浏览器中残留的旧存储数据，避免历史数据干扰：

1. 打开浏览器 F12 → 进入 **Application → Storage → Local Storage**。

2. 分别删除

   ```
   localhost:5173
   ```

   和

   ```
   localhost:5174
   ```

   下的以下键（若存在）：

   - `pinia/user`（5173 旧存储）
   - `token`（5174 旧存储）
   - `userInfo`（5174 旧存储）

3. 重启两个项目，此时 5174 不会再自动读取 5173 的 Token，需手动登录。

#### 总结

问题根源是 **“同名 Pinia Store + 自动持久化” 导致的存储冲突**，解决方案围绕 “**给存储 key 加唯一标识**” 展开，前端修改后配合后端校验，可彻底避免跨项目自动登录的问题。后续从 GitHub clone 项目时，只要确保 Store ID 和存储 key 与本地其他项目不重复，就不会出现类似问题。                   







