# 功能：

## 前台功能：

### 首页：

顶部导航栏从左到右显示首页，关于我们，租赁中心，新闻资讯，客服中心。

搜索图标（鼠标移入时弹出搜索框），

用户图标（未登录时点击进入登录页面；登陆后点击进入个人页面），

购物车图标（鼠标移入时弹出一小栏购物车【显示 “商品缩略图 + 产品名称 + 租赁规格（如 3 天 50 元 / 天）+ 数量 + 小计价格”，用户无需进入购物车详情，即可快速确认商品信息，减少操作步骤。】

未登录时也可以把物品加入购物车，登陆后把未登录中的购物车中的东西和账号已有的购物车中的东西合并，一小栏购物车下面有一个按钮名为“去购物车结算”，点击进入购物车详情页面）。

首页有三种样式的轮播图。点击图片时会根据图片的productId匹配产品的id，匹配到两者相等则跳转到对应的产品详情页面（如果没有匹配到则弹出信息‘未找到该商品’）

首页还有一个视频轮播组件和轮播图组件类似，只是图片换成了视频，且同样可以根据匹配id跳转到详情页面。

首页最下面是一个静态页脚组件。



### 关于我们：

最上面是一张图片显示关于我们。

中间及一下主要是用于介绍我们公司的静态页面。



### 租赁中心：

最上面是一张照片显示租赁中心。

下面是类似这样的：

<img src="./images/产品中心展示.png" alt="产品展示" style="zoom:75%;" />

可以根据产品类别【无人机，手持设备，微单相机，单反相机】和品牌【大疆，影石，索尼，佳能，尼康，富士】分页（每页20个产品）显示对应的产品，可以同时选择一个产品类别和品牌类别来查看产品卡片，如果用户的组合不存在，显示当前未找到您想要的产品，然后下面显示【热门推荐】组件，点击对应的产品可以进入产品详情页面，默认排序是根据首字母【A-Z】排序，右边有一个【按照评分排序】点击后产品按照评分从高到底排序。



### 产品详情页面：

左边是图片展示，每个产品拥有五张图片（正方形），右边从上到下显示

照片下面显示的是该产品的平均评分（会根据这个产品下面每条评论的打分来计算打分平均数）

产品名称（举例：尼康D850，大疆Osmo Action 5Pro），

产品特点简介(举例：全新 1/1.3 英寸传感器，旗舰影像 | 人物居中，锁定主角 | 双 OLED 高亮触摸屏 | 360° 地平线增稳，硬核防抖 | 大容量电池，4 小时超长续航 | 双 DJI 麦克直连，专业收音)，

产品品牌（举例：大疆，索尼，佳能，尼康，富士），

产品Id（举例：Nikon-D850，DJI-OsmoAction4），

租赁规格自己选择租赁日期【几天（3-180天）】（3-5天，一天50）（6-15天，一天40）（16-30，一天30）（31-180天，一天15），会直接把价格说明标注在旁边，每种产品租凭时间区间一样但是价格不一样（无人机：3-5天，一天200）

需要缴纳【押金 × 元（租完验收无误后退还）】

数量选择（不能为0和负数），旁边显示库存数量，选择的数量不能超过库存数，当某商品的库存数量为0的时候，该商品无法点击加入购物车。【管理员可以在后台页面修改库存数量】

加入购物车按钮，点击后会加入购物车。

下方还有商品的品牌详情介绍和产品详情介绍。

一个发表评论栏【打星（1-5），评论，上传照片（最多支持上传三张照片），点击发布按钮】

最下面是分页显示评论，评论包括【文字评论（50字上限）、评分(1-5 星)、评论时间、用户账号，点赞和点踩】，自己和其他用户都可以点赞或者点踩，只能点一方，如果已经点踩了，再去点赞就会取消点踩，评论默认按时间排序显示，第一页显示最新的评论。



### 新闻资讯：

最上面是一张照片显示新闻资讯。

下面是一块一块的新闻【块里面包含：图片，新闻标题，发布时间，修改时间，发布人】，分页显示，每页只显示9块新闻，按照发布时间排序，第一页显示最新的新闻。

点击会进入新闻详情页面【从上到下：标题，发布时间，修改时间，发布人，正文（采用md文档转换成的，前端添加 “MD 图片自适应规则”：“MD 文档中的图片自动适配页面宽度（最大宽度 100%），点击图片可查看原图”，确保阅读流畅。），返回按钮（返回到显示一块一块新闻资讯的分页页面，位置会固定在页面右侧）】



### 客服中心：

最上面是一张照片显示客服中心。

中间是一个提出问题的模块，用户可以输入问题，选择问题的类型【租金问题，押金问题，下单问题，保险问题，售后问题，其他问题】，后台页面会接收到该问题，当管理员在后台填写这个问题的回答之后，这个问题就会显示到相关的问题模块里面。

用户提交问题后，需显示 “提交成功！管理员将在 24 小时内回复

下面是6块常见问题【租金问题，押金问题，下单问题，保险问题，售后问题，其他问题】，点击相关问题进入相关问题的详情页面。

进入后会有一条一条的块，里面包含问题和回答，分页显示，每页显示20条问题。【里面暗含了创建时间和修改时间，按照创建时间排列问题，最新的问题显示在第一页】，右边会在页面上固定一个返回按钮点击返回到上一个页面。

<img src="./images/问题模块.png" alt="问题模块" style="zoom:75%;" />





### 搜索页面：

在搜索栏输入信息可以经行对【产品名称】和【新闻标题】的模糊查找。

搜索显示的内容分为两类，产品块和新闻块，点击【产品】按钮和【新闻】按钮可以来查看搜索到的产品和新闻。

当用户搜索的关键词无法查到的时候，页面中显示【暂时未找到该关键词】，下面是一个【热门推荐】的组件



### 登陆注册：

登录页面如下：

<img src="./images/登录页面.png" alt="登录页面" style="zoom:75%;" />

注册页面如下：

<img src="./images/注册页面.png" alt="注册页面" style="zoom:75%;" />





### 个人中心：

#### 个人信息及修改：

<img src="./images/修改基本信息.png" alt="修改个人信息" style="zoom:75%;" />



#### 修改密码：

<img src="./images/修改密码.png" alt="修改密码" style="zoom:75%;" />

#### 身份证上传功能：

上传身份证正面图片：上传到个人信息的idCardPhoto中并且可以在这个页面看见，提供 “重新上传” 按钮。

上传页面说明：身份证信息仅用于租赁身份验证，平台将加密存储，不会泄露给任何第三方；



#### 管理收货地址的功能：

收货地址【收货人，联系方式，收货地址，支付宝账号】，右边两个按钮【切换地址】，【添加地址】，切换地址的时候选择哪个，哪个就是默认地址。默认地址会显示在管理地址这个地方。

增加地址的时候注意：前端需强制校验 “收货人、手机号、地址、支付宝账号” 是否完整（如手机号格式错误、地址为空时，禁用 “提交订单” 按钮），避免订单信息无效



#### 订单列表：

分为【全部订单，待付款，待收货，待归还，已完成，已取消】

从左到右分别为：订单编号，

订购的产品名称（可能有好几个，换行排列），

每个产品后面显示数量，

订单总额，

订单状态【待付款，待收货，待归还，已完成，已取消】，

创建时间，

查看详情。

在订单详情页 / 订单列表（待归还状态）新增**超时前倒计时**，具体显示：

- 待归还状态初始：“待归还（需在租期结束后 3 天内提交归还单号，剩余 2 天 23 小时）”；
- 倒计时 <24 小时：文字变橙色，提示 “仅剩 23 小时需提交归还单号，超时将按 50 元 / 天扣押金”；
- 超时后：文字变红，标注 “已超时 1 天，已扣 50 元押金，仍需尽快提交归还单号”，让用户提前感知风险，减少纠纷。



#### 归还快递页面：

用于查看归还的快递是否被平台签收，主要显示如下：

之前的订单号，退货快递编号，平台是否签收，押金是否退回。





### 订单详情页面：

点击查看详情进入该订单的详情页面，从上到下：

订单状态【待付款，待收货，待归还，已完成，已取消】

收货地址【姓名，电话，地址，支付宝账号】，

订购的产品信息【产品名称，产品Id，租赁规格，租赁数量，该商品的租赁价格】，

总价格，

下单时间，

订单编号，

快递编号。

最下面有

继续付款（当订单状态是【待付款】时才能点击，点击后订单状态变成【待收货】）

取消按钮（当订单状态是【待付款】时才能点击，点击后订单状态变成【已取消】）

确认收货（当订单是【待收货】状态时才能点击，点击后订单状态变成【待归还】）

如果用户超时3天未提交归还快递单号，会从押金中按照每天扣除租金【如何判断？从创建订单的时候+自己选择的租期+三天，超过这个时间订单状态还是【待归还】状态则会把订单颜色变成红色后面会加上红色的超时】

在订单详情页 / 订单列表（待归还状态）新增**超时前倒计时**，具体显示：

- 待归还状态初始：“待归还（需在租期结束后 3 天内提交归还单号，剩余 2 天 23 小时）”；
- 倒计时 <24 小时：文字变橙色，提示 “仅剩 23 小时需提交归还单号，超时将按 50 元 / 天扣押金”；
- 超时后：文字变红，标注 “已超时 1 天，已扣 50 元押金，仍需尽快提交归还单号”，让用户提前感知风险，减少纠纷。
- 超时未提交归还单号，按您租赁时选择的租期梯度单价扣押金（例：您选 10 天租期，按 40 元 / 天扣）

归还按钮（当订单状态是【待归还】的时候点击，点击后弹出一个输入快递单号的输入框，用户需要输入退回快递的订单号，管理员会在后台操作，当收到用户寄回的快递时，由管理员来修改订单的状态为【已完成】）

给订单添加一个定时器，在【待付款 】状态保持超过10分钟自动变成【已取消】状态

当订单状态变成【已取消】的时候，减少的相关库存会再重新添加回去。

最下面添加说明：

- 验收标准：列出 “不影响押金退还” 的正常磨损（如轻微划痕）和 “需扣押金” 的损坏（如镜头碎裂、机身进水），附示例图；
- 退还时效：“收到归还商品并验收无误后，1-3 个工作日内退还押金至原支付账户”；
- 争议处理：“若对验收结果有异议，可在 24 小时内提交商品照片 / 视频，平台将在 48 小时内复核”。



### 购物车详情：

点击购物小栏上的【去购物车结算】按钮进入购物车详情页面。

从左到右显示：

勾选框【有是否全选的按钮】

商品信息【产品的第一张图片+产品名称】

租赁规格自己选择租赁日期【几天（3-180天）】（3-5天，一天50）（6-15天，一天40）（16-30，一天30）（31-180天，一天15）（可以点击切换租赁规格，同时价格也会改变，注意这一点）

数量，价格小计，操作【删除】

最下面是一个价格总计【共x件商品，已选择y件，商品合计多少钱】，只有勾选框选上的商品价格才会进入合计。

右边是一个【下单结算】按钮，点击进入创建订单页面。



### 创建订单页面：

最上面是收货地址【收货人，联系方式，收货地址，支付宝账号】，右边两个按钮【切换地址】，【添加地址】

增加地址的时候注意：前端需强制校验 “收货人、手机号、地址、支付宝账号” 是否完整（如手机号格式错误、地址为空时，禁用 “提交订单” 按钮），避免订单信息无效

默认【送货上门】

中间显示订单的商品信息：产品的第一张照片+产品名称，单价，数量，小计，实付，所有购买商品价格总计。

在「创建订单页」“商品信息汇总区” 补充：

- 押金明细：单独列出 “总押金：×× 元（含商品 A 500 元 + 商品 B 300 元）”，并标注 “租完验收无误后 1-3 个工作日退还”；
- 支付说明：“订单支付金额 = 租金总额 + 总押金，需一次性支付”，避免用户误解 “押金可后付”。

最下面是一个【提交订单】按钮，点击后成功创建订单并跳转到支付页面，此时订单状态为【待付款】（保持此状态10分钟自动变成【已取消】状态），成功创建订单后会根据订单中的产品的名称和数量去减少其相应的库存数量。



### 支付页面：

上面显示【订单提交成功！请尽快完成支付。还剩xx分钟xx秒，超时自动取消订单】右边显示需要支付的价格，

下面有两种支付平台，【微信支付】和【支付宝支付】，点击使该订单从【待支付】状态转变为【待收货】状态，页面跳转到用户个人页面下的订单列表。











































## 后台功能：



















































# 数据库设计(MongoDB)

## 用户表：









## 轮播图表







































# API接口



































# 前端

### 目录解析











































# 后端

### 目录解析

























# 优化点：

## 适配移动端框架，小屏显示

















# 遇见的问题

##  “**唯一标识存储**”“**切断跨源通道**”“**后端校验隔离**”

我先运行5173端口这个项目登录产生一个token存储在5173，后来我又运行另一个项目在端口5174，为什么这个项目会自动获取5173端口的token然后自动变成登录状态，而且数据也全部传过来，我清除5174的本地缓存之后，重新启动之后就没有了，两个网站的cookie都为空。我清除5174的本地缓存之后重新启动项目之后就没有了，需要自己登录。解释上面事情发生的原理，以及告诉我怎么避免我从github git clone这个项目启动后就会因为5173中存储的token而产生自动登录

要解决两个本地项目（5173/5174 端口）共享登录态的问题，需先明确**浏览器存储隔离规则**与**项目逻辑漏洞**的核心原理，再针对性切断跨源数据传递通道。

### 一、现象背后的核心原理

你遇到的 “5174 自动读取 5173 的 token”，本质是**前端存储跨源传递 + 项目逻辑未隔离**导致的，而非浏览器原生存储 “打破同源策略”（浏览器严格按「协议 + 域名 + 端口」隔离 localStorage/sessionStorage）。具体拆解为两个关键环节：

1. 浏览器存储的 “隔离性” 与 “可传递性”

浏览器的`localStorage`/`sessionStorage`遵循**同源策略**：仅允许当前「协议 + 域名 + 端口」的页面读写自身存储（例：`localhost:5173`的存储无法被`localhost:5174`直接读取）。但以下场景会导致跨源传递 token：

- **存储 key 冲突 + 跨源数据注入**：两个项目存储 token 的 key 相同（如都用`token`作为 key），且 5173 通过「跨源通信」将 token 传递给 5174（如 5173 的页面用`postMessage`发送 token，5174 的页面监听`postMessage`并将 token 存入自身`localStorage`）。
- **浏览器插件 / 缓存干扰**：部分跨域调试插件、缓存同步插件可能绕过同源策略，将 5173 的存储数据同步到 5174；或浏览器缓存了 5173 的 token 请求，5174 启动时复用了缓存的 token 响应。

2. 项目逻辑的 “未隔离” 漏洞

- **token 读取未校验来源**：5174 的代码仅判断 “是否存在`token` key”，未校验 token 是否属于自身项目（如未附加项目标识），直接使用了 5173 注入的 token。
- **后端会话未隔离**：若两个项目对接同一后端，后端未按项目 / 端口隔离登录会话（如仅用 IP 识别用户），5173 登录后，5174 请求接口时后端误将其关联到 5173 的会话，返回登录态。

### 二、避免自动登录的解决方案

核心目标：**切断 5174 获取 5173 token 的通道** + **确保 5174 仅使用自身源的有效 token**，具体分 5 步落地：

1. **让 token 存储 “带唯一标识”，避免冲突**

两个项目用相同的`key`（如`token`）存储，是跨源复用的直接诱因。需给存储 key 加 “项目专属标识”：

- 修改存储 key

  ：将存储 token 的 key 从通用名改为 “项目 + 端口” 唯一值，例：

  javascript

  ```javascript
  // 5174项目的存储逻辑（替换原代码）
  const TOKEN_KEY = `token_${import.meta.env.VITE_PORT}`; // 用环境变量区分端口
  // 存储token
  localStorage.setItem(TOKEN_KEY, token);
  // 读取token（仅读自身key）
  const token = localStorage.getItem(TOKEN_KEY);
  ```

- **清除历史冲突 key**：启动 5174 前，手动删除浏览器中`localhost:5174`下的旧`token`（浏览器 F12→Application→Storage→Local Storage→找到`localhost:5174`→删除`token`条目）。

2. **切断跨源数据传递通道**

若项目中存在`postMessage`（跨页面通信）逻辑，需限制其 “仅接收可信源”，避免 5173 注入 token：

- 检查并修改 postMessage 监听

  ：删除无限制的

  ```
  message
  ```

  事件监听，或添加源校验：

  javascript

  ```javascript
  // 错误写法（无限制接收）
  window.addEventListener('message', (e) => {
    if (e.data.type === 'TOKEN') localStorage.setItem('token', e.data.value); // 风险！
  });
  
  // 正确写法（仅接收自身源或可信域名）
  window.addEventListener('message', (e) => {
    // 仅允许当前项目源（5174）或后端域名发送消息
    const trustedOrigins = ['http://localhost:5174', 'https://your-backend.com'];
    if (!trustedOrigins.includes(e.origin)) return; // 非可信源直接忽略
    if (e.data.type === 'TOKEN') localStorage.setItem(TOKEN_KEY, e.data.value);
  });
  ```

- **禁用跨源干扰插件**：关闭浏览器中 “跨域调试”“缓存同步” 类插件（如 CORS Unblock、Cache Killer），这类插件可能绕过同源策略同步存储数据。

3. **让后端 “隔离会话”，拒绝其他项目的 token**

若两个项目对接同一后端，需让后端按 “项目标识” 区分登录会话，避免复用 5173 的 token：

- 请求时附加项目标识

  ：5174 请求接口时，在 Header 中添加专属标识（如端口），例：

  javascript

  ```javascript
  // 5174项目的请求拦截器（Axios为例）
  axios.interceptors.request.use((config) => {
    config.headers['X-Project-Port'] = import.meta.env.VITE_PORT; // 传递5174端口
    config.headers['Authorization'] = `Bearer ${token}`;
    return config;
  });
  ```

- **后端校验项目标识**：后端接收到请求后，先校验`X-Project-Port`与 token 的关联性（如 token 中嵌入端口信息），若 token 属于 5173（端口不匹配），则返回 “token 无效”，强制 5174 重新登录。

4. **优化 Vite 开发环境隔离**

Vite 开发环境的默认配置可能存在 “源混淆”，需通过`vite.config.js`强化隔离：

javascript

```javascript
// vite.config.js
export default defineConfig({
  server: {
    port: 5174, // 固定端口
    headers: {
      'Cache-Control': 'no-store', // 禁用浏览器缓存，避免复用5173的token缓存
      'X-Frame-Options': 'DENY', // 禁止嵌入5173的iframe，切断iframe跨源通信
    },
    origin: 'http://localhost:5174', // 明确当前源，避免Vite返回模糊源导致混淆
  },
  define: {
    'import.meta.env.VITE_PORT': JSON.stringify(5174), // 注入端口环境变量（供存储key使用）
  },
});
```

5. 启动时 “校验 token 有效性”，而非直接使用

即使 5174 的存储中存在 token，也需先向后端验证是否属于自身项目，避免无效 token 自动登录：

javascript

```javascript
// 5174项目启动时的登录态校验逻辑
async function checkLoginState() {
  const token = localStorage.getItem(TOKEN_KEY);
  if (!token) return false; // 无token，跳转登录

  try {
    // 向后端发送“token有效性校验请求”
    const res = await axios.get('/api/check-token', {
      headers: { 'X-Project-Port': import.meta.env.VITE_PORT },
    });
    return res.data.valid; // 后端返回true则保持登录，false则清除token
  } catch (err) {
    localStorage.removeItem(TOKEN_KEY); // 校验失败，清除token
    window.location.href = '/login'; // 跳转登录页
    return false;
  }
}

// 项目初始化时执行校验
checkLoginState();
```

### 三、总结

问题根源是「存储 key 冲突 + 跨源数据传递 + 后端会话未隔离」，解决方案围绕 “**唯一标识存储**”“**切断跨源通道**”“**后端校验隔离**” 三个核心，确保 5174 仅使用自身生成的有效 token，彻底避免 “clone 项目后自动登录” 的情况。



### 解决方法：

结合你提供的 **5173（小兔鲜）** 和 **5174（租客行）** 项目完整代码，自动登录的核心原因是 **Pinia Store ID 冲突 + 持久化存储跨项目复用**，而非浏览器原生跨源读取。以下是具体原理拆解和可直接落地的解决方案：

#### 一、自动登录的根本原因（从代码中定位）

两个项目的 **Pinia 状态管理逻辑** 和 **持久化存储配置** 存在冲突，导致 5174 误读了 5173 存储的 Token，具体分 3 步：

1. **5173 项目：Pinia 自动持久化 Token 到 localStorage**

5173 的 `useUserStore` 配置了 **`persist: true`**（Pinia Persisted State 插件的核心配置）：

javascript

```javascript
// 5173 的 useUserStore（关键代码）
export const useUserStore = defineStore(
  'user', // Store ID 为 "user"
  () => { /* 状态逻辑 */ },
  {
    persist: true // 开启自动持久化：将 Store 数据存到 localStorage
  }
)
```

- **持久化规则**：Pinia Persisted State 插件会默认将 Store 数据存入 `localStorage`，存储的 **key 为 `pinia/${storeId}`**（即 `pinia/user`）。
- **存储内容**：5173 登录后，`userStore.userInfo` 包含 Token，插件会自动将 `userInfo`（含 Token）写入 `localStorage` 的 `pinia/user` 键中。

2. **5174 项目：误读 5173 的 Pinia 持久化存储**

5174 的 `useUserStore` 虽然没有显式配置 `persist: true`，但存在两个关键漏洞：

- **Store ID 冲突**：5174 的 Store ID 也为 `user`（与 5173 完全一致）：

  javascript

  ```javascript
  // 5174 的 useUserStore（关键代码）
  export const useUserStore = defineStore('user', { /* 状态逻辑 */ })
  ```

  若 5174 项目中 **安装了 Pinia Persisted State 插件**（即使未显式配置 `persist`），插件会默认读取 `localStorage` 中 `pinia/user` 键的数据（即 5173 存储的 Token），并注入到 5174 的 `userStore` 中。

- **手动读取存储未做隔离**：5174 的 `userStore` 手动从 `localStorage` 读取 `token` 和 `userInfo`：

  javascript

  ```javascript
  // 5174 的 userStore 初始化（关键代码）
  state: () => ({
    token: localStorage.getItem('token') || '', // 读取 "token" 键
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null') // 读取 "userInfo" 键
  })
  ```

  若 5173 有逻辑（如插件、误写代码）将 `pinia/user` 中的 Token 复制到 `token` 键，5174 会直接读取该 Token 并用于请求。

3. **后端未校验 Token 归属，直接通过认证**

两个项目若对接 **同一后端**，后端仅验证 Token 有效性（如签名是否正确），未校验 Token 属于哪个项目（5173/5174），导致 5174 携带 5173 的 Token 请求时，后端认为是合法登录态，返回用户数据。

#### 二、彻底解决：3 步切断跨项目 Token 复用

核心目标：**让两个项目的存储 key 完全不冲突** + **确保 Token 仅归属自身项目**，以下是可直接复制修改的代码方案：

**第一步：给 Pinia Store 加 “项目专属 ID”，避免冲突**

两个项目的 Store ID 均为 `user` 是冲突根源，需添加项目 / 端口标识：

javascript

```javascript
// 1. 5173 项目：修改 useUserStore 的 Store ID（加端口标识）
export const useUserStore = defineStore(
  'user_5173', // 专属 ID：项目名+端口
  () => {
    // 原有逻辑不变（userInfo、getUserInfo、clearUserInfo）
  },
  {
    persist: true,
    // 可选：显式指定持久化 key，避免插件默认规则变动
    persist: {
      key: 'pinia_user_5173', // 自定义存储 key，与 5174 完全不同
      paths: ['userInfo'] // 仅持久化 userInfo，减少冗余
    }
  }
)

// 2. 5174 项目：修改 useUserStore 的 Store ID（加端口标识）
export const useUserStore = defineStore(
  'user_5174', // 专属 ID：项目名+端口
  {
    state: () => ({
      // 手动存储的 key 也加专属标识
      token: localStorage.getItem('token_5174') || '',
      userInfo: JSON.parse(localStorage.getItem('userInfo_5174') || 'null')
    }),
    actions: {
      // 修改 saveLoginInfo：存储到专属 key
      saveLoginInfo(token: string, userInfo: UserInfo) {
        this.token = token;
        this.userInfo = userInfo;
        // 存储到加标识的 key
        localStorage.setItem('token_5174', token);
        localStorage.setItem('userInfo_5174', JSON.stringify(userInfo));
      },
      // 修改 logout：清除专属 key
      logout() {
        this.token = '';
        this.userInfo = null;
        localStorage.removeItem('token_5174');
        localStorage.removeItem('userInfo_5174');
      }
    }
  }
)
```

**第二步：5174 禁用不必要的 Pinia Persist 插件**

若 5174 不需要自动持久化（已手动处理 `localStorage`），需彻底移除 Pinia Persisted State 插件，避免误读：

1. 卸载插件

   （终端执行）：

   bash

   ```bash
   npm uninstall pinia-plugin-persistedstate
   # 或 yarn remove pinia-plugin-persistedstate
   ```

2. 删除插件注册代码

   （通常在

   ```
   main.js
   ```

   或

   ```
   store/index.js
   ```

   ）：

   javascript

   ```javascript
   // 删掉类似以下的代码（5174 项目）
   import { createPinia } from 'pinia';
   import piniaPluginPersistedstate from 'pinia-plugin-persistedstate';
   const pinia = createPinia();
   pinia.use(piniaPluginPersistedstate); // 移除这行
   ```

**第三步：后端加 Token 归属校验（关键补充）**

仅前端处理仍有风险（如 Token 被手动复制），需后端配合校验 Token 是否属于当前项目：

1. 前端请求时附加项目标识

   ：在请求头添加项目 / 端口信息，5173 和 5174 分别传不同值：

   javascript

   ```javascript
   // 5173 的 request 拦截器（修改）
   request.interceptors.request.use((config) => {
     const userStore = useUserStore();
     if (userStore.userInfo.token) {
       config.headers.Authorization = `Bearer ${userStore.userInfo.token}`;
       config.headers['X-Project-Id'] = 'project_5173'; // 项目专属标识
     }
     return config;
   });
   
   // 5174 的 request 拦截器（修改）
   request.interceptors.request.use((config) => {
     const userStore = useUserStore();
     if (userStore.token) {
       config.headers.Authorization = `Bearer ${userStore.token}`;
       config.headers['X-Project-Id'] = 'project_5174'; // 项目专属标识
     }
     return config;
   });
   ```

2. **后端校验**：解析 Token 时，同时检查 `X-Project-Id` 是否与 Token 生成时的项目一致（如 Token payload 中嵌入项目 ID），不一致则返回 401 错误。

三、验证与清理：确保旧数据不干扰

修改后需清除浏览器中残留的旧存储数据，避免历史数据干扰：

1. 打开浏览器 F12 → 进入 **Application → Storage → Local Storage**。

2. 分别删除

   ```
   localhost:5173
   ```

   和

   ```
   localhost:5174
   ```

   下的以下键（若存在）：

   - `pinia/user`（5173 旧存储）
   - `token`（5174 旧存储）
   - `userInfo`（5174 旧存储）

3. 重启两个项目，此时 5174 不会再自动读取 5173 的 Token，需手动登录。

#### 总结

问题根源是 **“同名 Pinia Store + 自动持久化” 导致的存储冲突**，解决方案围绕 “**给存储 key 加唯一标识**” 展开，前端修改后配合后端校验，可彻底避免跨项目自动登录的问题。后续从 GitHub clone 项目时，只要确保 Store ID 和存储 key 与本地其他项目不重复，就不会出现类似问题。                   







